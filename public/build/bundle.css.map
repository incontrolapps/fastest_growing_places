{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "BarChart.svelte",
    "ColumnChart.svelte",
    "LineChart.svelte",
    "ScatterChart.svelte",
    "AxisX.svelte",
    "AxisY.svelte",
    "Footer.svelte",
    "Labels.svelte",
    "Legend.svelte",
    "Line.svelte",
    "Title.svelte",
    "Voronoi.svelte",
    "Map.svelte",
    "MapTooltip.svelte",
    "LayerCake.svelte",
    "Html.svelte",
    "ScaledSvg.svelte",
    "Svg.svelte",
    "App.svelte",
    "Divider.svelte",
    "Filler.svelte",
    "Header.svelte",
    "Media.svelte",
    "ONSFooter.svelte",
    "ONSHeader.svelte",
    "Scroller.svelte",
    "Arrow.svelte",
    "Em.svelte",
    "Toggle.svelte",
    "App.svelte",
    "Axis.svelte",
    "Key.svelte",
    "ZoomSvg.svelte"
  ],
  "sourcesContent": [
    "<svelte:options accessors={true} />\n\n<script>\n\timport { LayerCake, Svg } from 'layercake';\n\timport { scaleBand, scaleOrdinal, scaleLinear, scaleSymlog } from 'd3-scale';\n  import { tweened } from 'svelte/motion';\n\timport { cubicInOut } from 'svelte/easing';\n\timport { groupData, stackData } from '../js/utils';\n\n\timport SetCoords from './shared/SetCoords.svelte';\n\timport Bar from './shared/Bar.svelte';\n\timport AxisX from './shared/AxisX.svelte';\n\timport AxisY from './shared/AxisY.svelte';\n\timport Legend from './shared/Legend.svelte';\n\timport Title from './shared/Title.svelte';\n\timport Footer from './shared/Footer.svelte';\n\n  export let data;\n\texport let height = 250; // number of pixels or valid css height string\n  export let animation = true;\n  export let duration = 800;\n\texport let xKey = 'x';\n\texport let yKey = 'y';\n\texport let zKey = null;\n\texport let idKey = yKey;\n\texport let xScale = 'linear';\n\texport let xFormatTick = d => d;\n\texport let xMax = null;\n\texport let xMin = 0;\n  export let xAxis = true;\n  export let yAxis = true;\n\texport let xTicks = 4;\n\texport let textColor = '#666';\n\texport let tickColor = '#ccc';\n\texport let tickDashed = false;\n\texport let title = null;\n\texport let footer = null;\n\texport let legend = false;\n\texport let snapTicks = false;\n\texport let mode = 'default'; // options: 'default', 'comparison', 'marker', 'stacked', 'grouped'\n\texport let padding = { top: 0, bottom: 20, left: 35, right: 0 };\n\texport let color = null;\n\texport let colors = color ? [color] : ['#206095', '#A8BD3A', '#003C57', '#27A0CC', '#118C7B', '#F66068', '#746CB1', '#22D0B6', 'lightgrey'];\n\texport let markerWidth = 2.5;\n\texport let spacing = 0.05; // proportion of bar width (1 = 100%)\n\texport let interactive = true;\n\texport let xPrefix = \"\";\n\texport let xSuffix = \"\";\n\texport let yPrefix = \"\";\n\texport let ySuffix = \"\";\n\texport let hover = false;\n\texport let hovered = null;\n\texport let colorHover = 'orange';\n\texport let select = false;\n\texport let selected = null;\n\texport let colorSelect = 'black';\n\texport let highlighted = [];\n\texport let colorHighlight = 'black';\n\texport let overlayFill = false;\n\n\tconst tweenOptions = {\n\t\tduration: duration,\n\t\teasing: cubicInOut\n\t};\n\tconst coords = tweened(undefined, tweenOptions);\n\n\tconst distinct = (d, i, arr) => arr.indexOf(d) ==  i;\n\n\tfunction getTotals(data, keys) {\n\t\tlet arr = [];\n\t\tkeys.forEach(key => {\n\t\t\tlet vals = data.filter(d => d[yKey] == key).map(d => d[xKey]);\n\t\t\tlet sum = vals.reduce((a, b) => a + b, 0);\n\t\t\tarr.push(sum);\n\t\t});\n\t\treturn arr;\n\t}\n\n\t// Functions to update xDomain\n\tconst xDomSet = (data, mode, xKey, xMax) => xMax ? [xMin, xMax] : mode == 'stacked' && zKey ? [xMin, Math.max(...getTotals(data, data.map(d => d[yKey]).filter(distinct)))] : [xMin, Math.max(...data.map(d => d[xKey]))];\n\tfunction xDomUpdate(data, mode, xKey, xMax) {\n\t\tlet newXDom = xDomSet(data, mode, xKey, xMax);\n\t\tif (newXDom[0] != xDom[0] || newXDom[1] != xDom[1]) {\n\t\t\txDomain.set(newXDom, {duration: animation ? duration : 0});\n\t\t\txDom = newXDom;\n\t\t}\n\t}\n\tlet xDom = xDomSet(data, mode, xKey, xMax);\n\tconst xDomain = tweened(xDom, tweenOptions);\n\t$: xDomUpdate(data, mode, xKey, xMax);\n\n\t// Functions to update yDomain & zDomain\n\t$: yDomain = data.map(d => d[yKey]).filter(distinct);\n\t$: zDomain = zKey ? data.map(d => d[zKey]).filter(distinct) : null;\n\n\t// Create a data series for each zKey (group)\n\t$: groupedData = mode == 'stacked' ? stackData(data, zDomain, xKey, zKey) : groupData(data, zDomain, zKey);\n</script>\n\n{#if title}\n  <Title>{title}</Title>\n{/if}\n<slot name=\"options\"/>\n<div class=\"chart-container\" style=\"height: {typeof height == 'number' ? height + 'px' : height }\">\n\t<LayerCake\n\t\t{padding}\n\t\tx={xKey}\n\t\ty={yKey}\n\t\tz={zKey}\n\t\txDomain={$xDomain}\n\t\t{yDomain}\n\t\txScale={xScale == 'log' ? scaleSymlog() : scaleLinear()}\n\t\tyScale={scaleBand().paddingInner([spacing]).round(true)}\n\t\tzScale={scaleOrdinal()}\n\t\t{zDomain}\n\t\tzRange={colors}\n\t\tdata={groupedData}\n\t\tflatData={data}\n\t\tcustom={{\n\t\t\ttype: 'bar',\n\t\t\tmode,\n\t\t\tidKey,\n      coords,\n\t\t\tmarkerWidth,\n\t\t\tcolorSelect,\n\t\t\tcolorHover,\n\t\t\tcolorHighlight,\n      animation,\n      duration\n    }}\n\t\tlet:width\n\t>\n\t  {#if width > 80} <!-- Hack to prevent rendering before xRange/yRange initialised -->\n\t  <SetCoords/>\n\t  <slot name=\"back\"/>\n\t\t<Svg pointerEvents={interactive}>\n      {#if xAxis}\n\t\t\t  <AxisX ticks={xTicks} formatTick={xFormatTick} {snapTicks} prefix={xPrefix} suffix={xSuffix} {textColor} {tickColor} {tickDashed}/>\n      {/if}\n      {#if yAxis}\n\t\t\t  <AxisY gridlines={false} prefix={yPrefix} suffix={ySuffix} {textColor} {tickColor} {tickDashed}/>\n      {/if}\n\t\t\t<Bar {select} {selected} {hover} {hovered} {highlighted} on:hover on:select {overlayFill}/>\n\t\t\t<slot name=\"svg\"/>\n\t\t</Svg>\n\t  <slot name=\"front\"/>\n\t\t{/if}\n\t</LayerCake>\n</div>\n{#if legend && zDomain}\n  <Legend domain={zDomain} {colors} {markerWidth} horizontal={false} line={mode == 'barcode'} comparison={mode == 'comparison'}/>\n{/if}\n{#if footer}\n  <Footer>{footer}</Footer>\n{/if}\n\n<style>\n\t.chart-container {\n\t\twidth: 100%;\n\t}\n</style>",
    "<svelte:options accessors={true} />\n\n<script>\n\timport { LayerCake, Svg } from 'layercake';\n\timport { scaleBand, scaleOrdinal, scaleLinear, scaleSymlog } from 'd3-scale';\n  import { tweened } from 'svelte/motion';\n\timport { cubicInOut } from 'svelte/easing';\n\timport { groupData, stackData } from '../js/utils';\n\n\timport SetCoords from './shared/SetCoords.svelte';\n\timport Column from './shared/Column.svelte';\n\timport AxisX from './shared/AxisX.svelte';\n\timport AxisY from './shared/AxisY.svelte';\n\timport Legend from './shared/Legend.svelte';\n\timport Title from './shared/Title.svelte';\n\timport Footer from './shared/Footer.svelte';\n\n  export let data;\n\texport let height = 250; // number of pixels or valid css height string\n  export let animation = true;\n  export let duration = 800;\n\texport let xKey = 'x';\n\texport let yKey = 'y';\n\texport let zKey = null;\n\texport let idKey = xKey;\n\texport let yScale = 'linear';\n\texport let yFormatTick = d => d;\n\texport let yMax = null;\n\texport let yMin = 0;\n  export let xAxis = true;\n  export let yAxis = true;\n\texport let yTicks = 4;\n\texport let title = null;\n\texport let footer = null;\n\texport let legend = false;\n\texport let mode = 'default'; // options: 'default', 'comparison', 'marker', 'stacked', 'grouped'\n\texport let padding = { top: 0, bottom: 20, left: 35, right: 0 };\n\texport let color = null;\n\texport let colors = color ? [color] : ['#206095', '#A8BD3A', '#003C57', '#27A0CC', '#118C7B', '#F66068', '#746CB1', '#22D0B6', 'lightgrey'];\n\texport let markerWidth = 2.5\n\texport let spacing = 0.05 // proportion of bar width (1 = 100%)\n\texport let interactive = true;\n\texport let xPrefix = \"\";\n\texport let xSuffix = \"\";\n\texport let yPrefix = \"\";\n\texport let ySuffix = \"\";\n\texport let hover = false;\n\texport let hovered = null;\n\texport let colorHover = 'orange';\n\texport let select = false;\n\texport let selected = null;\n\texport let colorSelect = 'black';\n\texport let highlighted = [];\n\texport let colorHighlight = 'black';\n\texport let overlayFill = false;\n\n\tconst tweenOptions = {\n\t\tduration: duration,\n\t\teasing: cubicInOut\n\t};\n\tconst coords = tweened(undefined, tweenOptions);\n\n\tconst distinct = (d, i, arr) => arr.indexOf(d) ==  i;\n\n\tfunction getTotals(data, keys) {\n\t\tlet arr = [];\n\t\tkeys.forEach(key => {\n\t\t\tlet vals = data.filter(d => d[xKey] == key).map(d => d[yKey]);\n\t\t\tlet sum = vals.reduce((a, b) => a + b, 0);\n\t\t\tarr.push(sum);\n\t\t});\n\t\treturn arr;\n\t}\n\n\t// Functions to animate yDomain\n\tconst yDomSet = (data, mode, yKey, yMax) => yMax ? [yMin, yMax] : mode == 'stacked' && yKey ? [yMin, Math.max(...getTotals(data, data.map(d => d[xKey]).filter(distinct)))] : [yMin, Math.max(...data.map(d => d[yKey]))];\n\tfunction yDomUpdate(data, mode, yKey, yMax) {\n\t\tlet newYDom = yDomSet(data, mode, yKey, yMax);\n\t\tif (newYDom[0] != yDom[0] || newYDom[1] != yDom[1]) {\n\t\t\tyDomain.set(newYDom, {duration: animation ? duration : 0});\n\t\t\tyDom = newYDom;\n\t\t}\n\t}\n\tlet yDom = yDomSet(data, mode, yKey, yMax);\n\tconst yDomain = tweened(yDom, tweenOptions);\n\t$: yDomUpdate(data, mode, yKey, yMax);\n\n\t// Functions to update xDomain & zDomain\n\t$: xDomain = data.map(d => d[xKey]).filter(distinct);\n\t$: zDomain = zKey ? data.map(d => d[zKey]).filter(distinct) : null;\n\n\t// Create a data series for each zKey (group)\n\t$: groupedData = mode == 'stacked' ? stackData(data, zDomain, yKey, zKey) : groupData(data, zDomain, zKey);\n</script>\n\n{#if title}\n  <Title>{title}</Title>\n{/if}\n<slot name=\"options\"/>\n<div class=\"chart-container\" style=\"height: {typeof height == 'number' ? height + 'px' : height }\">\n\t<LayerCake\n\t\t{padding}\n\t\tx={xKey}\n\t\ty={yKey}\n\t\tz={zKey}\n\t\t{xDomain}\n\t\tyDomain={$yDomain}\n\t\t{zDomain}\n\t\txScale={scaleBand().paddingInner([spacing]).round(true)}\n\t\tyScale={yScale == 'log' ? scaleSymlog() : scaleLinear()}\n\t\tzScale={scaleOrdinal()}\n\t\tzRange={colors}\n\t\tdata={groupedData}\n\t\tflatData={data}\n\t\tcustom={{\n\t\t\ttype: 'column',\n\t\t\tmode,\n\t\t\tidKey,\n      coords,\n\t\t\tmarkerWidth,\n\t\t\tcolorSelect,\n\t\t\tcolorHover,\n\t\t\tcolorHighlight,\n      animation,\n      duration\n    }}\n\t\tlet:width\n\t>\n\t  {#if width > 80} <!-- Hack to prevent rendering before xRange/yRange initialised -->\n\t\t<SetCoords/>\n\t  <slot name=\"back\"/>\n\t\t<Svg pointerEvents={interactive}>\n      {#if xAxis}\n\t\t\t  <AxisX gridlines={false} prefix={xPrefix} suffix={xSuffix}/>\n      {/if}\n      {#if yAxis}\n\t\t\t  <AxisY ticks={yTicks} formatTick={yFormatTick} prefix={yPrefix} suffix={ySuffix}/>\n      {/if}\n\t\t\t<Column {select} {selected} {hover} {hovered} {highlighted} on:hover on:select {overlayFill}/>\n\t\t\t<slot name=\"svg\"/>\n\t\t</Svg>\n\t  <slot name=\"front\"/>\n\t\t{/if}\n\t</LayerCake>\n</div>\n{#if legend && zDomain}\n  <Legend domain={zDomain} {colors} {markerWidth} line={mode == 'barcode'} comparison={mode == 'comparison'}/>\n{/if}\n{#if footer}\n  <Footer>{footer}</Footer>\n{/if}\n\n<style>\n\t.chart-container {\n\t\twidth: 100%;\n\t}\n</style>",
    "<svelte:options accessors={true} />\n\n<script>\n\timport { LayerCake, Svg } from 'layercake';\n\timport { scaleOrdinal, scaleLinear, scaleSymlog } from 'd3-scale';\n  import { tweened } from 'svelte/motion';\n\timport { cubicInOut } from 'svelte/easing';\n\timport { groupData, stackData } from '../js/utils';\n\n\timport SetCoords from './shared/SetCoords.svelte';\n\timport Line from './shared/Line.svelte';\n\timport Area from './shared/Area.svelte';\n\timport AxisX from './shared/AxisX.svelte';\n\timport AxisY from './shared/AxisY.svelte';\n\timport Legend from './shared/Legend.svelte';\n\timport Title from './shared/Title.svelte';\n\timport Footer from './shared/Footer.svelte';\n\timport Labels from './shared/Labels.svelte';\n\n  export let data;\n\texport let height = 250; // number of pixels or valid css height string\n  export let animation = true;\n  export let duration = 800;\n\texport let xKey = 'x';\n\texport let yKey = 'y';\n\texport let zKey = null;\n\texport let idKey = zKey;\n\texport let labelKey = idKey;\n\texport let yScale = 'linear';\n\texport let yFormatTick = d => d;\n\texport let yMax = null;\n\texport let yMin = 0;\n  export let xAxis = true;\n  export let yAxis = true;\n\texport let xTicks = 4;\n\texport let yTicks = 4;\n\texport let title = null;\n\texport let footer = null;\n\texport let legend = false;\n\texport let labels = false;\n\texport let snapTicks = true;\n  export let line = true;\n  export let area = true;\n\texport let mode = 'default';\n\texport let areaOpacity = 1;\n\texport let padding = { top: 0, bottom: 20, left: 35, right: 0 };\n\texport let color = null;\n\texport let colors = color ? [color] : ['#206095', '#A8BD3A', '#003C57', '#27A0CC', '#118C7B', '#F66068', '#746CB1', '#22D0B6', 'lightgrey'];\n\texport let lineWidth = 2.5;\n\texport let interactive = true;\n\texport let xPrefix = \"\";\n\texport let xSuffix = \"\";\n\texport let yPrefix = \"\";\n\texport let ySuffix = \"\";\n\texport let hover = false;\n\texport let hovered = null;\n\texport let colorHover = 'orange';\n\texport let select = false;\n\texport let selected = null;\n\texport let colorSelect = '#206095';\n\texport let highlighted = [];\n\texport let colorHighlight = '#206095';\n\n\tconst tweenOptions = {\n\t\tduration: duration,\n\t\teasing: cubicInOut\n\t};\n\tconst coords = tweened(undefined, tweenOptions);\n\n\tconst distinct = (d, i, arr) => arr.indexOf(d) ==  i;\n\n\tfunction getTotals(data, keys) {\n\t\tlet arr = [];\n\t\tkeys.forEach(key => {\n\t\t\tlet vals = data.filter(d => d[xKey] == key).map(d => d[yKey]);\n\t\t\tlet sum = vals.reduce((acc, curr) => acc + curr);\n\t\t\tarr.push(sum);\n\t\t});\n\t\treturn arr;\n\t}\n\n\t// Functions to animate yDomain\n\tconst yDomSet = (data, mode, yKey, yMax) => yMax ? [yMin, yMax] : mode == 'stacked' && yKey ? [yMin, Math.max(...getTotals(data, data.map(d => d[xKey]).filter(distinct)))] : [yMin, Math.max(...data.map(d => d[yKey]))];\n\tfunction yDomUpdate(data, mode, yKey, yMax) {\n\t\tlet newYDom = yDomSet(data, mode, yKey, yMax);\n\t\tif (newYDom[0] != yDom[0] || newYDom[1] != yDom[1]) {\n\t\t\tyDomain.set(newYDom, {duration: animation ? duration : 0});\n\t\t\tyDom = newYDom;\n\t\t}\n\t}\n\tlet yDom = yDomSet(data, mode, yKey, yMax);\n\tconst yDomain = tweened(yDom, tweenOptions);\n\t$: yDomUpdate(data, mode, yKey, yMax);\n\t\n\t// Function to update zDomain\n\t$: zDomain = zKey ? data.map(d => d[zKey]).filter(distinct) : null;\n\n\t// Create a data series for each zKey (group)\n\t$: groupedData = mode == 'stacked' ? stackData(data, zDomain, yKey, zKey) : groupData(data, zDomain, zKey);\n</script>\n\n{#if title}\n  <Title>{title}</Title>\n{/if}\n<slot name=\"options\"/>\n<div class=\"chart-container\" style=\"height: {typeof height == 'number' ? height + 'px' : height }\">\n\t<LayerCake\n\t\t{padding}\n\t\tx={xKey}\n\t\ty={yKey}\n\t\tz={zKey}\n\t\tyDomain={$yDomain}\n\t\tyScale={yScale == 'log' ? scaleSymlog() : scaleLinear()}\n\t\tzScale={scaleOrdinal()}\n\t\t{zDomain}\n\t\tzRange={colors}\n\t\tdata={groupedData}\n\t\tflatData={data}\n\t\tcustom={{\n\t\t\ttype: 'line',\n\t\t\tmode,\n\t\t\tidKey,\n\t\t\tlabelKey,\n\t\t\tcoords,\n\t\t\tcolorSelect,\n\t\t\tcolorHover,\n\t\t\tcolorHighlight,\n      animation,\n      duration\n    }}\n\t\tlet:width\n\t>\n\t  {#if width > 80} <!-- Hack to prevent rendering before xRange/yRange initialised -->\n\t\t<SetCoords/>\n\t  <slot name=\"back\"/>\n\t\t<Svg pointerEvents={interactive}>\n      {#if xAxis}\n\t\t\t  <AxisX ticks={xTicks} {snapTicks} prefix={xPrefix} suffix={xSuffix}/>\n      {/if}\n      {#if yAxis}\n\t\t\t  <AxisY ticks={yTicks} formatTick={yFormatTick} prefix={yPrefix} suffix={ySuffix}/>\n      {/if}\n      {#if area}\n\t\t\t  <Area {mode} opacity={areaOpacity}/>\n      {/if}\n      {#if line}\n\t\t\t  <Line {lineWidth} {select} bind:selected {hover} bind:hovered {highlighted} on:hover on:select/>\n      {/if}\n\t\t\t{#if labels}\n\t\t\t\t<Labels {hovered} {selected}/>\n\t\t\t{/if}\n\t\t\t<slot name=\"svg\"/>\n\t\t</Svg>\n\t  <slot name=\"front\"/>\n\t\t{/if}\n\t</LayerCake>\n</div>\n{#if legend && zDomain}\n  <Legend domain={zDomain} {colors} {line} markerWidth={lineWidth}/>\n{/if}\n{#if footer}\n  <Footer>{footer}</Footer>\n{/if}\n\n<style>\n\t.chart-container {\n\t\twidth: 100%;\n\t}\n</style>",
    "<script>\n  import { LayerCake, Svg } from 'layercake'\n  import { scaleOrdinal, scaleLinear, scaleSymlog } from 'd3-scale'\n  import { tweened } from 'svelte/motion'\n  import { cubicInOut } from 'svelte/easing'\n\n  import SetCoords from './shared/SetCoords.svelte'\n  import Scatter from './shared/Scatter.svg.svelte'\n  import Voronoi from './shared/Voronoi.svelte'\n  import AxisX from './shared/AxisX.svelte'\n  import AxisY from './shared/AxisY.svelte'\n  import Legend from './shared/Legend.svelte'\n  import Title from './shared/Title.svelte'\n  import Footer from './shared/Footer.svelte'\n  import Labels from './shared/Labels.svelte'\n\n  export let data\n  export let height = 250 // number of pixels or valid css height string\n  export let animation = true\n  export let duration = 800\n  export let xKey = 'x'\n  export let yKey = null\n  export let zKey = null\n  export let rKey = null\n  export let idKey = xKey\n  export let labelKey = idKey\n  export let xScale = 'linear'\n  export let yScale = 'linear'\n  export let xFormatTick = (d) => d\n  export let yFormatTick = (d) => d\n  export let xMax = null\n  export let xMin = null\n  export let yMax = null\n  export let yMin = null\n  export let xAxis = true\n  export let yAxis = true\n  export let xTicks = 4\n  export let yTicks = 4\n  export let textColor = '#666'\n  export let tickColor = '#ccc'\n  export let tickDashed = false\n  export let title = null\n  export let footer = null\n  export let legend = false\n  export let labels = false\n  export let snapTicks = false\n  export let padding = { top: 0, bottom: 20, left: 35, right: 0 }\n  export let buffer = 5\n  export let color = null\n  export let colors = color\n    ? [color]\n    : [\n        '#206095',\n        '#A8BD3A',\n        '#003C57',\n        '#27A0CC',\n        '#118C7B',\n        '#F66068',\n        '#746CB1',\n        '#22D0B6',\n        'lightgrey',\n      ]\n  export let r = 4\n  export let interactive = true\n  export let xPrefix = ''\n  export let xSuffix = ''\n  export let yPrefix = ''\n  export let ySuffix = ''\n  export let hover = false\n  export let hovered = null\n  export let colorHover = 'orange'\n  export let select = false\n  export let selected = null\n  export let colorSelect = 'black'\n  export let highlighted = []\n  export let colorHighlight = 'black'\n  export let overlayFill = false\n\n  const tweenOptions = {\n    duration: duration,\n    easing: cubicInOut,\n  }\n  const coords = tweened(undefined, tweenOptions)\n\n  const distinct = (d, i, arr) => arr.indexOf(d) == i\n\n  function domGet(data, key, min, max) {\n    let vals = data.map((d) => d[key])\n    return [\n      min ? min : vals[0] ? Math.min(...vals) : -1,\n      max ? max : vals[0] ? Math.max(...vals) : 1,\n    ]\n  }\n  function xDomUpdate(data, key, min, max) {\n    let newDom = domGet(data, key, min, max)\n    if (newDom[0] != xDom[0] || newDom[1] != xDom[1]) {\n      xDomain.set(newDom)\n      xDom = newDom\n    }\n  }\n  function yDomUpdate(data, key, min, max) {\n    let newDom = key ? domGet(data, key, min, max) : yDom\n    if (newDom[0] != yDom[0] || newDom[1] != yDom[1]) {\n      yDomain.set(newDom, { duration: animation ? duration : 0 })\n      yDom = newDom\n    }\n  }\n  let xDom = domGet(data, xKey, xMin, xMax)\n  const xDomain = tweened(xDom, tweenOptions)\n  let yDom = domGet(data, yKey, yMin, yMax)\n  const yDomain = tweened(yDom, tweenOptions)\n\n  $: xDomUpdate(data, xKey, xMin, xMax)\n  $: yDomUpdate(data, yKey, yMin, yMax)\n  $: zDomain = zKey ? data.map((d) => d[zKey]).filter(distinct) : null\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n  }\n</style>\n\n<svelte:options accessors={true} />\n{#if title}\n  <Title>{title}</Title>\n{/if}\n<slot name=\"options\" />\n<div\n  class=\"chart-container\"\n  style=\"height: {typeof height == 'number' ? height + 'px' : height}\">\n  <LayerCake\n    {padding}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    r={rKey}\n    xScale={xScale == 'log' ? scaleSymlog() : scaleLinear()}\n    yScale={yScale == 'log' ? scaleSymlog() : scaleLinear()}\n    zScale={scaleOrdinal()}\n    xDomain={$xDomain}\n    yDomain={$yDomain}\n    {zDomain}\n    zRange={colors}\n    rRange={Array.isArray(r) ? r : [r, r]}\n    {data}\n    xPadding={[buffer, buffer]}\n    yPadding={yKey ? [buffer, buffer] : null}\n    custom={{ type: 'scatter', idKey, labelKey, coords, colorSelect, colorHover, colorHighlight, padding: 1, animation, duration }}\n    let:width>\n    {#if width > 80}\n      <!-- Hack to prevent rendering before xRange/yRange initialised -->\n      <SetCoords />\n      <slot name=\"back\" />\n      <Svg pointerEvents={interactive}>\n        {#if xAxis}\n          <AxisX\n            ticks={xTicks}\n            formatTick={xFormatTick}\n            {snapTicks}\n            prefix={xPrefix}\n            suffix={xSuffix}\n            {textColor}\n            {tickColor}\n            {tickDashed} />\n        {/if}\n        {#if yAxis && yKey}\n          <AxisY\n            ticks={yTicks}\n            formatTick={yFormatTick}\n            prefix={yPrefix}\n            suffix={ySuffix}\n            {textColor}\n            {tickColor}\n            {tickDashed} />\n        {/if}\n        <Scatter {selected} {hovered} {highlighted} {overlayFill} />\n        {#if select || hover}\n          <Voronoi\n            {select}\n            bind:selected\n            {hover}\n            bind:hovered\n            {highlighted}\n            on:hover\n            on:select />\n        {/if}\n        {#if labels}\n          <Labels {hovered} {selected} />\n        {/if}\n        <slot name=\"svg\" />\n      </Svg>\n      <slot name=\"front\" />\n    {/if}\n  </LayerCake>\n</div>\n{#if legend && zDomain}\n  <Legend\n    domain={zDomain}\n    {colors}\n    markerLength={Array.isArray(r) ? r[0] * 2 : r * 2}\n    round={true} />\n{/if}\n{#if footer}\n  <Footer>{footer}</Footer>\n{/if}\n",
    "<script>\n\timport { getContext } from 'svelte';\n\n\tconst { width, height, xScale, yRange } = getContext('LayerCake');\n\n\texport let gridlines = true;\n\texport let tickDashed = false;\n\texport let tickMarks = false;\n\texport let tickColor = '#bbb';\n\texport let textColor = '#666';\n\texport let formatTick = d => d;\n\texport let snapTicks = false;\n\texport let ticks = undefined;\n\texport let xTick = undefined;\n\texport let yTick = 16;\n\texport let dxTick = 0;\n\texport let dyTick = 0;\n\texport let prefix = '';\n\texport let suffix = '';\n\n\t$: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n\t$: tickVals = Array.isArray(ticks) ? ticks :\n\t\tisBandwidth ?\n\t\t\t$xScale.domain() :\n\t\t\ttypeof ticks === 'function' ?\n\t\t\t\tticks($xScale.ticks()) :\n\t\t\t\t\t$xScale.ticks(ticks);\n\n\tfunction textAnchor(i) {\n\t\tif (snapTicks === true) {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 'start';\n\t\t\t}\n\t\t\tif (i === tickVals.length - 1) {\n\t\t\t\treturn 'end';\n\t\t\t}\n\t\t}\n\t\treturn 'middle';\n\t}\n</script>\n\n<g class='axis x-axis' class:snapTicks>\n\t{#each tickVals as tick, i}\n\t\t<g class='tick tick-{tick}' transform='translate({$xScale(tick)},{$yRange[0]})'>\n\t\t\t{#if gridlines !== false}\n\t\t\t\t<line class=\"gridline\" class:dashed={tickDashed} y1='{$height * -1}' y2='0' x1='0' x2='0' style='stroke: {tickColor}'></line>\n\t\t\t{/if}\n\t\t\t{#if tickMarks === true}\n\t\t\t\t<line class=\"tick-mark\" y1='{0}' y2='{6}' x1='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}' x2='{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}' style='stroke: {tickColor}'></line>\n\t\t\t{/if}\n\t\t\t<text\n\t\t\t\tx=\"{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\"\n\t\t\t\ty='{yTick}'\n\t\t\t\tdx='{dxTick}'\n\t\t\t\tdy='{dyTick}'\n\t\t\t\ttext-anchor='{textAnchor(i)}'\n\t\t\t\tstyle='fill: {textColor}'>\n\t\t\t\t\t{i == tickVals.length - 1 ? prefix + formatTick(tick) + suffix : formatTick(tick)}\n\t\t\t\t</text>\n\t\t</g>\n\t{/each}\n</g>\n\n<style>\n\t.tick {\n\t\tfont-size: .8em;\n\t}\n\n\t.tick .tick-mark,\n\t.tick.tick-0 line {\n\t\tstroke-dasharray: 0;\n\t}\n\n\t.dashed {\n\t\tstroke-dasharray: 2;\n\t}\n\t/* This looks slightly better */\n\t.axis.snapTicks .tick:last-child text {\n\t\ttransform: translateX(3px);\n\t}\n\t.axis.snapTicks .tick.tick-0 text {\n\t\ttransform: translateX(-3px);\n\t}\n</style>\n",
    "<script>\n\timport { getContext } from 'svelte';\n\n\tconst { padding, xRange, yScale } = getContext('LayerCake');\n\n\texport let ticks = 4;\n\texport let tickMarks = false;\n\texport let gridlines = true;\n\texport let tickDashed = false;\n\texport let tickColor = '#bbb';\n\texport let textColor = '#666';\n\texport let formatTick = d => d;\n\texport let xTick = 0;\n\texport let yTick = 0;\n\texport let dxTick = 0;\n\texport let dyTick = -4;\n\texport let textAnchor = 'start';\n\texport let prefix = '';\n\texport let suffix = '';\n\n\t$: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n\t$: tickVals = Array.isArray(ticks) ? ticks :\n\t\tisBandwidth ?\n\t\t\t$yScale.domain() :\n\t\t\ttypeof ticks === 'function' ?\n\t\t\t\tticks($yScale.ticks()) :\n\t\t\t\t\t$yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n\t{#each tickVals as tick, i}\n\t\t<g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n\t\t\t{#if gridlines !== false}\n\t\t\t\t<line\n\t\t\t\t\tclass=\"gridline\"\n\t\t\t\t\tx2='100%'\n\t\t\t\t\ty1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n\t\t\t\t\ty2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n\t\t\t\t\tclass:dashed={tickDashed}\n\t\t\t\t\tstyle='stroke: {tickColor}'\n\t\t\t\t></line>\n\t\t\t{/if}\n\t\t\t{#if tickMarks === true}\n\t\t\t\t<line\n\t\t\t\t\tclass='tick-mark'\n\t\t\t\t\tx1='0'\n\t\t\t\t\tx2='{isBandwidth ? -6 : 6}'\n\t\t\t\t\ty1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n\t\t\t\t\ty2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n\t\t\t\t\tstyle='stroke: {tickColor}'\n\t\t\t\t></line>\n\t\t\t{/if}\n\t\t\t<text\n\t\t\t\tx='{xTick}'\n\t\t\t\ty='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n\t\t\t\tdx='{isBandwidth ? -4 : dxTick}'\n\t\t\t\tdy='{isBandwidth ? 4 : dyTick}'\n\t\t\t\tstyle=\"text-anchor:{isBandwidth ? 'end' : textAnchor}; fill: {textColor}\">\n\t\t\t\t\t{i == tickVals.length - 1 ? prefix + formatTick(tick) + suffix : formatTick(tick)}\n\t\t\t\t</text>\n\t\t</g>\n\t{/each}\n</g>\n\n<style>\n\t.tick {\n\t\tfont-size: .8em;\n\t}\n\n\t.dashed {\n\t\tstroke-dasharray: 2;\n\t}\n\n\t.tick.tick-0 line {\n\t\tstroke-dasharray: 0;\n\t}\n</style>\n",
    "<div class=\"footer\"><slot/></div>\n\n<style>\n\t.footer {\n\t\tfont-size: .8em;\n\t\tcolor: grey;\n\t\tmargin-top: 5px;\n\t}\n</style>",
    "<script>\n\timport { getContext } from 'svelte';\n\n\tconst { data, xScale, yScale, custom } = getContext('LayerCake');\n\n\texport let hovered = null;\n\texport let selected = null;\n\t\n\tlet coords = $custom.coords;\n\tlet idKey = $custom.idKey;\n\tlet labelKey = $custom.labelKey;\n\t// let colorHover = $custom.colorHover ? $custom.colorHover : 'orange';\n\t// let colorSelect = $custom.colorSelect ? $custom.colorSelect : '#206095';\n</script>\n\n{#if $coords}\n<defs>\n\t<filter x=\"0\" y=\"0\" width=\"1\" height=\"1\" id=\"bgfill\">\n\t\t<feFlood flood-color=\"rgba(255,255,255,0.8)\" result=\"bg\" />\n\t\t<feMerge>\n\t\t\t<feMergeNode in=\"bg\"/>\n\t\t\t<feMergeNode in=\"SourceGraphic\"/>\n\t\t</feMerge>\n\t</filter>\n</defs>\n<g class=\"label-group\">\n\t{#if $coords[0] && $coords[0].x}\n\t{#each $coords as d, i}\n\t\t{#if [hovered, selected].includes($data[i][idKey])}\n\t\t<text\n\t\t\tclass=\"label\"\n\t\t\ttransform=\"translate(5,-5)\"\n\t\t\tfilter=\"url(#bgfill)\"\n\t\t\tfill=\"#333\"\n\t\t  x={$xScale(d.x)}\n\t\t\ty={$yScale(d.y)}>\n\t\t\t{$data[i][labelKey]}\n\t\t</text>\n\t\t{/if}\n\t{/each}\n\t{:else if $coords[0] && $coords[0][0] && $coords[0][0].x}\n\t{#each $coords as d, i}\n\t\t{#if [hovered, selected].includes($data[i][0][idKey])}\n\t\t<text\n\t\t\tclass=\"label\"\n\t\t\ttransform=\"translate(2,3)\"\n\t\t\tfilter=\"url(#bgfill)\"\n\t\t\tfill=\"#333\"\n\t\t  x={$xScale(d[d.length - 1].x)}\n\t\t\ty={$yScale(d[d.length - 1].y)}>\n\t\t\t{$data[i][0][labelKey]}\n\t\t</text>\n\t\t{/if}\n\t{/each}\n\t{/if}\n</g>\n{/if}\n\n<style>\n\t.label {\n\t\tfont-size: 0.8em;\n\t}\n</style>",
    "<script>\n  export let domain = null;\n  export let colors = null;\n  export let line = false; // true if line chart\n  export let comparison = false; // true if chart uses bars + markers for comparison\n  export let horizontal = true; // true if marker lines should be horizontal, false if vertical\n  export let markerWidth = 2.5;\n  export let markerLength = 13;\n  export let round = false; // to represent round markers\n</script>\n\n{#if Array.isArray(domain) && Array.isArray(colors)}\n  <ul class=\"legend\">\n    {#each domain as label, i}\n      <li>\n        <div\n          class=\"bullet\"\n          class:round\n          style=\"background-color: {colors[i]}; width: {!horizontal && (line || (comparison && i != 0)) ? markerWidth : markerLength}px; height: {horizontal && (line || (comparison && i != 0)) ? markerWidth : markerLength}px\"\n        />\n        {label}\n      </li>\n    {/each}\n  </ul>\n{/if}\n\n<style>\n  ul.legend {\n    margin: 0;\n    padding: 0;\n  }\n  ul.legend li {\n    display: inline;\n    font-size: .8em;\n  }\n  ul.legend li + li {\n    margin-left: 8px;\n  }\n  .bullet {\n\t\tdisplay: inline-block;\n    vertical-align: middle;\n\t}\n  .round {\n    border-radius: 50%;\n  }\n</style>",
    "<script>\n\timport { getContext, createEventDispatcher } from 'svelte';\n\n\tconst { data, xScale, yScale, zGet, config, custom } = getContext('LayerCake');\n\tconst dispatch = createEventDispatcher();\n\n\texport let lineWidth = 2.5;\n\texport let hover = false;\n\texport let hovered = null;\n\texport let select = false;\n\texport let selected = null;\n\texport let highlighted = [];\n\t\n\tlet coords = $custom.coords;\n\tlet idKey = $custom.idKey;\n\tlet colorHover = $custom.colorHover ? $custom.colorHover : 'orange';\n\tlet colorSelect = $custom.colorSelect ? $custom.colorSelect : '#206095';\n\tlet colorHighlight = $custom.colorHighlight ? $custom.colorHighlight : '#206095';\n\n\t// Function to make SVG path\n\tconst makePath = (group) => {\n\t\tlet path = 'M' + group\n\t\t.map(d => {\n\t\t\treturn $xScale(d.x) + ',' + $yScale(d.y);\n\t\t})\n\t\t.join('L');\n\t\treturn path;\n\t}\n\n\tfunction doHover(e, d) {\n\t\tif (hover) {\n\t\t\thovered = d ? d[0][idKey] : null;\n\t\t\tdispatch('hover', {\n\t\t\t\tid: hovered,\n\t\t\t\tdata: d,\n\t\t\t\tevent: e\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction doSelect(e, d) {\n\t\tif (select) {\n\t\t\tselected = d ? d[0][idKey] : null;\n\t\t\tdispatch('select', {\n\t\t\t\tid: selected,\n\t\t\t\tdata: d,\n\t\t\t\tevent: e\n\t\t\t});\n\t\t}\n\t}\n</script>\n\n{#if $coords}\n<g class=\"line-group\">\n\t{#each $coords as group, i}\n\t\t<path\n\t\t  class=\"path-hover\"\n\t\t\td=\"{makePath(group)}\"\n\t\t\ton:mouseover={e => doHover(e, $data[i])}\n\t\t\ton:mouseleave={e => doHover(e, null)}\n\t\t\ton:focus={e => doHover(e, $data[i])}\n\t\t\ton:blur={e => doHover(e, null)}\n\t\t\ton:click={e => doSelect(e, $data[i])}\n\t\t/>\n\t  <path\n\t\t  class=\"path-line\"\n\t\t\td=\"{makePath(group)}\"\n\t\t\tstroke=\"{\n\t\t\t\t$config.z ? $zGet($data[i][0]) : $config.zRange[0]}\"\n\t\t\tstroke-width=\"{\n\t\t\t\tlineWidth\n\t\t\t}\"\n\t\t/>\n\t{/each}\n\t\n\t{#if idKey && (hover || selected || highlighted[0])}\n\t{#each $coords as group, i}\n\t\t{#if [hovered, selected, ...highlighted].includes($data[i][0][idKey]) }\n\t  <path\n\t\t  class=\"path-overlay\"\n\t\t\td=\"{makePath(group)}\"\n\t\t\tstroke=\"{\n\t\t\t\t$data[i][0][idKey] == hovered ? colorHover :\n\t\t\t\t$data[i][0][idKey] == selected ? colorSelect :\n\t\t\t\tcolorHighlight\n\t\t\t}\"\n\t\t\tstroke-width=\"{\n\t\t\t\tlineWidth + 1.5\n\t\t\t}\"\n\t\t/>\n\t\t{/if}\n\t{/each}\n\t{/if}\n</g>\n{/if}\n\n<style>\n\tpath {\n\t\tfill: none;\n\t\tstroke-linejoin: round;\n\t\tstroke-linecap: round;\n\t}\n\t.path-hover {\n\t\tstroke: rgba(255,255,255,0);\n\t\tstroke-width: 7;\n\t}\n\t.path-line, .path-overlay {\n\t\tpointer-events: none;\n\t}\n</style>\n\n\n",
    "<div class=\"title\"><slot/></div>\n\n<style>\n\t.title {\n\t\tfont-size: 1.1em;\n\t\tfont-weight: bold;\n\t\tmargin-bottom: 10px;\n\t}\n</style>",
    "<script>\n\timport { Delaunay } from 'd3-delaunay';\n\timport { getContext, createEventDispatcher } from 'svelte';\n\n\tconst { data, width, height, custom, xScale, yScale } = getContext('LayerCake');\n\tconst dispatch = createEventDispatcher();\n\n\texport let hover = false;\n\texport let hovered = null;\n\texport let select = false;\n\texport let selected = null;\n\n\tlet coords = $custom.coords;\n\tlet idKey = $custom.idKey;\n\n\tfunction doHover(e, d) {\n\t\tif (hover) {\n\t\t\thovered = d ? d[idKey] : null;\n\t\t\tdispatch('hover', {\n\t\t\t\tid: hovered,\n\t\t\t\tdata: d,\n\t\t\t\tevent: e\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction doSelect(e, d) {\n\t\tif (select) {\n\t\t\tselected = d ? d[idKey] : null;\n\t\t\tdispatch('select', {\n\t\t\t\tid: selected,\n\t\t\t\tdata: d,\n\t\t\t\tevent: e\n\t\t\t});\n\t\t}\n\t}\n\n\t$: coordsArray = Array.isArray($coords) ? $coords.map(d => [$xScale(d.x), $yScale(d.y)]) : [];\n\t$: voronoi = Delaunay.from(coordsArray).voronoi([0, 0, $width, $height]);\n\n</script>\n\n<style>\n\t.voronoi-cell {\n\t\tfill: none;\n\t\tstroke: none;\n\t\tpointer-events: all;\n\t}\n</style>\n\n{#if voronoi}\n<g class=\"voronoi-group\">\n{#each $data as d, i}\n\t<path\n\t\tclass=\"voronoi-cell\"\n\t\td={voronoi.renderCell(i)}\n\t\ton:mouseover={e => doHover(e, $data[i])}\n\t\ton:mouseleave={e => doHover(e, null)}\n\t\ton:focus={e => doHover(e, $data[i])}\n\t\ton:blur={e => doHover(e, null)}\n\t\ton:click={e => doSelect(e, $data[i])}\n\t/>\n{/each}\n</g>\n{/if}\n",
    "<script>\n\timport { onMount, setContext } from \"svelte\";\n\timport mapbox from \"./lib/mapbox-gl@1.13.2\";\n\t// Mapbox source code is bundled due to versioning & ES6 import issues\n\t// https://cdn.skypack.dev/-/mapbox-gl@v1.13.2-asizChmwkQobquJNQjgb/dist=es2020,mode=imports,min/optimized/mapbox-gl.js\n\n\texport let map;\n\texport let id = \"map\";\n\texport let location = {\n\t\tlng: 15,\n\t\tlat: 45,\n\t\tzoom: 1\n\t};\n\texport let style = {\n\t\t\"version\": 8,\n\t\t\"sources\": {},\n\t\t\"layers\": []\n\t};\n\texport let minzoom = 0;\n\texport let maxzoom = 14;\n\texport let controls = false;\n\texport let locate = false;\n\texport let tabbable = false;\n\n\texport let zoom = null;\n\texport let center = null;\n\texport let interactive = true;\n\n\tlet container;\n\tlet w;\n\tlet h;\n\tlet options;\n\tlet loaded = false;\n\n\tsetContext(\"map\", {\n\t\tgetMap: () => map,\n\t});\n\t\n\t// Interpret location\n\tif (location.bounds) {\n\t\toptions = { bounds: location.bounds };\n\t} else if (typeof location.lng == 'number' && typeof location.lat == 'number') {\n\t\toptions = {\n\t\t\tcenter: [location.lng, location.lat],\n\t\t};\n\t\tif (typeof location.zoom == 'number') {\n\t\t\toptions.zoom = location.zoom;\n\t\t}\n\t}\n\n\tonMount(() => {\n\t\tconst link = document.createElement(\"link\");\n\t\tlink.rel = \"stylesheet\";\n\t\tlink.href = \"https://unpkg.com/mapbox-gl@1.13.2/dist/mapbox-gl.css\";\n\n\t\tlink.onload = () => {\n\t\t\tmap = new mapbox.Map({\n\t\t\t\tcontainer,\n\t\t\t\tstyle,\n\t\t\t\tminZoom: minzoom,\n\t\t\t\tmaxZoom: maxzoom,\n\t\t\t\tinteractive,\n\t\t\t\t...options,\n\t\t\t});\n\t\t\t\n\t\t\tif (controls) {\n\t\t\t\tmap.addControl(new mapbox.NavigationControl({showCompass: false}));\n\t\t\t}\n\t\t\t\n\t\t\tif (locate) {\n\t\t\t\tmap.addControl(new mapbox.GeolocateControl());\n\t\t\t}\n\t\t\t\n\t\t\t// Get initial zoom level\n\t\t\tmap.on(\"load\", () => {\n\t\t\t\tzoom = map.getZoom();\n\t\t\t\tcenter = map.getCenter();\n\t\t\t\tloaded = true;\n\t\t\t\t\n\t\t\t\t// Prevent map from being tabbable\n\t\t\t\tif (!tabbable && document.querySelector(`#${id} canvas`)) {\n\t\t\t\t\tdocument.querySelector(`#${id} canvas`).tabIndex = \"-1\";\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Update zoom level and center when the view changes\n\t\t\tmap.on(\"moveend\", () => {\n\t\t\t\tzoom = map.getZoom();\n\t\t\t\tcenter = map.getCenter();\n\t\t\t});\n\t\t};\n\n\t\tdocument.head.appendChild(link);\n\n\t\treturn () => {\n\t\t\tmap.remove();\n\t\t\tlink.parentNode.removeChild(link);\n\t\t};\n\t});\n\n\t// Function that forces map to resize to fit parent div, in case it doesn't automatically\n\tfunction resizeCanvas() {\n\t\tif (loaded) {\n\t\t\tlet canvas = document.getElementsByClassName(\"mapboxgl-canvas\");\n\t\t  if (canvas[0]) {\n\t\t\t  canvas[0].style.width = \"100%\";\n\t\t\t  canvas[0].style.height = \"100%\";\n\t\t\t  map.resize();\n\t\t  }\n\t\t}\n\t}\n\n\t// Invoke above function when parent div size changes\n\t$: (w || h) && resizeCanvas();\n</script>\n\n<div bind:clientWidth={w} bind:clientHeight={h} bind:this={container} {id}>\n\t{#if loaded}\n\t\t<slot />\n\t{/if}\n</div>\n\n<style>\n\t:global(.mapboxgl-control-container button) {\n\t\tmargin: 0;\n\t}\n\tdiv {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t}\n</style>",
    "<script>\n  import { getContext } from 'svelte';\n  import mapbox from './lib/mapbox-gl@1.13.2';\n\t// Mapbox source code is bundled due to versioning & ES6 import issues\n\t// https://cdn.skypack.dev/-/mapbox-gl@v1.13.2-asizChmwkQobquJNQjgb/dist=es2020,mode=imports,min/optimized/mapbox-gl.js\n\n  export let content;\n\n  const tooltip = new mapbox.Popup({\n\t\tcloseButton: false,\n\t\tcloseOnClick: false\n\t});\n\n  const { getMap } = getContext('map');\n\tconst map = getMap();\n  const hoverObj = getContext('hover');\n\n  function updateTooltip(obj, content) {\n    if (obj.id) {\n      tooltip\n\t\t\t.setLngLat(obj.event.lngLat)\n      .setHTML(content ? content : obj.code)\n      .addTo(map);\n    } else {\n      tooltip.remove();\n    }\n  }\n\n  $: updateTooltip($hoverObj, content);\n</script>\n\n<style>\n  :global(.mapboxgl-popup-content) {\n\t\tpadding: 5px 10px !important;\n\t}\n</style>",
    "<script>\n\timport { setContext } from 'svelte';\n\timport { writable, derived } from 'svelte/store';\n\n\timport makeAccessor from './utils/makeAccessor.js';\n\timport filterObject from './utils/filterObject.js';\n\timport calcExtents from './lib/calcExtents.js';\n\timport calcDomain from './helpers/calcDomain.js';\n\timport createScale from './helpers/createScale.js';\n\timport createGetter from './helpers/createGetter.js';\n\timport getRange from './helpers/getRange.js';\n\timport defaultScales from './settings/defaultScales.js';\n\timport defaultReverses from './settings/defaultReverses.js';\n\n\texport let ssr = false;\n\texport let pointerEvents = true;\n\texport let position = 'relative';\n\texport let percentRange = false;\n\n\texport let width = undefined;\n\texport let height = undefined;\n\n\texport let containerWidth = width || 100;\n\texport let containerHeight = height || 100;\n\n\t/* --------------------------------------------\n\t * Parameters\n\t * Values that computed properties are based on and that\n\t * can be easily extended from config values\n\t *\n\t */\n\texport let x = undefined;\n\texport let y = undefined;\n\texport let z = undefined;\n\texport let r = undefined;\n\texport let custom = {};\n\texport let data = [];\n\texport let xDomain = undefined;\n\texport let yDomain = undefined;\n\texport let zDomain = undefined;\n\texport let rDomain = undefined;\n\texport let xNice = false;\n\texport let yNice = false;\n\texport let zNice = false;\n\texport let rNice = false;\n\texport let xReverse = defaultReverses.x;\n\texport let yReverse = defaultReverses.y;\n\texport let zReverse = defaultReverses.z;\n\texport let rReverse = defaultReverses.r;\n\texport let xPadding = undefined;\n\texport let yPadding = undefined;\n\texport let zPadding = undefined;\n\texport let rPadding = undefined;\n\texport let xScale = defaultScales.x;\n\texport let yScale = defaultScales.y;\n\texport let zScale = defaultScales.y;\n\texport let rScale = defaultScales.r;\n\texport let xRange = undefined;\n\texport let yRange = undefined;\n\texport let zRange = undefined;\n\texport let rRange = undefined;\n\texport let padding = {};\n\texport let extents = {};\n\texport let flatData = undefined;\n\n\t/* --------------------------------------------\n\t * Preserve a copy of our passed in settings before we modify them\n\t * Return this to the user's context so they can reference things if need be\n\t * Add the active keys since those aren't on our settings object.\n\t * This is mostly an escape-hatch\n\t */\n\tconst config = {};\n\t$: if (x) config.x = x;\n\t$: if (y) config.y = y;\n\t$: if (z) config.z = z;\n\t$: if (r) config.r = r;\n\t$: if (xDomain) config.xDomain = xDomain;\n\t$: if (yDomain) config.yDomain = yDomain;\n\t$: if (zDomain) config.zDomain = zDomain;\n\t$: if (rDomain) config.rDomain = rDomain;\n\t$: if (xRange) config.xRange = xRange;\n\t$: if (yRange) config.yRange = yRange;\n\t$: if (zRange) config.zRange = zRange;\n\t$: if (rRange) config.rRange = rRange;\n\n\t/* --------------------------------------------\n\t * Make store versions of each parameter\n\t * Prefix these with `_` to keep things organized\n\t */\n\tconst _percentRange = writable();\n\tconst _containerWidth = writable();\n\tconst _containerHeight = writable();\n\tconst _x = writable();\n\tconst _y = writable();\n\tconst _z = writable();\n\tconst _r = writable();\n\tconst _custom = writable();\n\tconst _data = writable();\n\tconst _xDomain = writable();\n\tconst _yDomain = writable();\n\tconst _zDomain = writable();\n\tconst _rDomain = writable();\n\tconst _xNice = writable();\n\tconst _yNice = writable();\n\tconst _zNice = writable();\n\tconst _rNice = writable();\n\tconst _xReverse = writable();\n\tconst _yReverse = writable();\n\tconst _zReverse = writable();\n\tconst _rReverse = writable();\n\tconst _xPadding = writable();\n\tconst _yPadding = writable();\n\tconst _zPadding = writable();\n\tconst _rPadding = writable();\n\tconst _xScale = writable();\n\tconst _yScale = writable();\n\tconst _zScale = writable();\n\tconst _rScale = writable();\n\tconst _xRange = writable();\n\tconst _yRange = writable();\n\tconst _zRange = writable();\n\tconst _rRange = writable();\n\tconst _padding = writable();\n\tconst _flatData = writable();\n\tconst _extents = writable();\n\tconst _config = writable(config);\n\n\t$: _percentRange.set(percentRange);\n\t$: _containerWidth.set(containerWidth);\n\t$: _containerHeight.set(containerHeight);\n\t$: _x.set(makeAccessor(x));\n\t$: _y.set(makeAccessor(y));\n\t$: _z.set(makeAccessor(z));\n\t$: _r.set(makeAccessor(r));\n\t$: _xDomain.set(xDomain);\n\t$: _yDomain.set(yDomain);\n\t$: _zDomain.set(zDomain);\n\t$: _rDomain.set(rDomain);\n\t$: _custom.set(custom);\n\t$: _data.set(data);\n\t$: _xNice.set(xNice);\n\t$: _yNice.set(yNice);\n\t$: _zNice.set(zNice);\n\t$: _rNice.set(rNice);\n\t$: _xReverse.set(xReverse);\n\t$: _yReverse.set(yReverse);\n\t$: _zReverse.set(zReverse);\n\t$: _rReverse.set(rReverse);\n\t$: _xPadding.set(xPadding);\n\t$: _yPadding.set(yPadding);\n\t$: _zPadding.set(zPadding);\n\t$: _rPadding.set(rPadding);\n\t$: _xScale.set(xScale);\n\t$: _yScale.set(yScale);\n\t$: _zScale.set(zScale);\n\t$: _rScale.set(rScale);\n\t$: _xRange.set(xRange);\n\t$: _yRange.set(yRange);\n\t$: _zRange.set(zRange);\n\t$: _rRange.set(rRange);\n\t$: _padding.set(padding);\n\t$: _extents.set(filterObject(extents));\n\t$: _flatData.set(flatData || data);\n\n\t/* --------------------------------------------\n\t * Create derived values\n\t * Suffix these with `_d`\n\t */\n\tconst activeGetters_d = derived([_x, _y, _z, _r], ([$x, $y, $z, $r]) => {\n\t\treturn [\n\t\t\t{ field: 'x', accessor: $x },\n\t\t\t{ field: 'y', accessor: $y },\n\t\t\t{ field: 'z', accessor: $z },\n\t\t\t{ field: 'r', accessor: $r }\n\t\t].filter(d => d.accessor);\n\t});\n\n\tconst padding_d = derived([_padding, _containerWidth, _containerHeight], ([$padding]) => {\n\t\tconst defaultPadding = { top: 0, right: 0, bottom: 0, left: 0 };\n\t\treturn Object.assign(defaultPadding, $padding);\n\t});\n\n\tconst box_d = derived([_containerWidth, _containerHeight, padding_d], ([$containerWidth, $containerHeight, $padding]) => {\n\t\tconst b = {};\n\t\tb.top = $padding.top;\n\t\tb.right = $containerWidth - $padding.right;\n\t\tb.bottom = $containerHeight - $padding.bottom;\n\t\tb.left = $padding.left;\n\t\tb.width = b.right - b.left;\n\t\tb.height = b.bottom - b.top;\n\t\tif (b.width < 0 && b.height < 0) {\n\t\t\tconsole.error('[LayerCake] Target div has negative width and height. Did you forget to set a width or height on the container?');\n\t\t} else if (b.width < 0) {\n\t\t\tconsole.error('[LayerCake] Target div has a negative width. Did you forget to set that CSS on the container?');\n\t\t} else if (b.height < 0) {\n\t\t\tconsole.error('[LayerCake] Target div has negative height. Did you forget to set that CSS on the container?');\n\t\t}\n\t\treturn b;\n\t});\n\n\tconst width_d = derived([box_d], ([$box]) => {\n\t\treturn $box.width;\n\t});\n\n\tconst height_d = derived([box_d], ([$box]) => {\n\t\treturn $box.height;\n\t});\n\n\t/* --------------------------------------------\n\t * Calculate extents by taking the extent of the data\n\t * and filling that in with anything set by the user\n\t */\n\tconst extents_d = derived([_flatData, activeGetters_d, _extents], ([$flatData, $activeGetters, $extents]) => {\n\t\treturn { ...calcExtents($flatData, $activeGetters.filter(d => !$extents[d.field])), ...$extents };\n\t});\n\n\tconst xDomain_d = derived([extents_d, _xDomain], calcDomain('x'));\n\tconst yDomain_d = derived([extents_d, _yDomain], calcDomain('y'));\n\tconst zDomain_d = derived([extents_d, _zDomain], calcDomain('z'));\n\tconst rDomain_d = derived([extents_d, _rDomain], calcDomain('r'));\n\n\tconst xScale_d = derived([_xScale, extents_d, xDomain_d, _xPadding, _xNice, _xReverse, width_d, height_d, _xRange, _percentRange], createScale('x'));\n\tconst xGet_d = derived([_x, xScale_d], createGetter);\n\n\tconst yScale_d = derived([_yScale, extents_d, yDomain_d, _yPadding, _yNice, _yReverse, width_d, height_d, _yRange, _percentRange], createScale('y'));\n\tconst yGet_d = derived([_y, yScale_d], createGetter);\n\n\tconst zScale_d = derived([_zScale, extents_d, zDomain_d, _zPadding, _zNice, _zReverse, width_d, height_d, _zRange, _percentRange], createScale('z'));\n\tconst zGet_d = derived([_z, zScale_d], createGetter);\n\n\tconst rScale_d = derived([_rScale, extents_d, rDomain_d, _rPadding, _rNice, _rReverse, width_d, height_d, _rRange, _percentRange], createScale('r'));\n\tconst rGet_d = derived([_r, rScale_d], createGetter);\n\n\tconst xRange_d = derived([xScale_d], getRange);\n\tconst yRange_d = derived([yScale_d], getRange);\n\tconst zRange_d = derived([zScale_d], getRange);\n\tconst rRange_d = derived([rScale_d], getRange);\n\n\tconst aspectRatio_d = derived([width_d, height_d], ([$aspectRatio, $width, $height]) => {\n\t\treturn $width / $height;\n\t});\n\n\t$: context = {\n\t\tactiveGetters: activeGetters_d,\n\t\twidth: width_d,\n\t\theight: height_d,\n\t\tpercentRange: _percentRange,\n\t\taspectRatio: aspectRatio_d,\n\t\tcontainerWidth: _containerWidth,\n\t\tcontainerHeight: _containerHeight,\n\t\tx: _x,\n\t\ty: _y,\n\t\tz: _z,\n\t\tr: _r,\n\t\tcustom: _custom,\n\t\tdata: _data,\n\t\txNice: _xNice,\n\t\tyNice: _yNice,\n\t\tzNice: _zNice,\n\t\trNice: _rNice,\n\t\txReverse: _xReverse,\n\t\tyReverse: _yReverse,\n\t\tzReverse: _zReverse,\n\t\trReverse: _rReverse,\n\t\txPadding: _xPadding,\n\t\tyPadding: _yPadding,\n\t\tzPadding: _zPadding,\n\t\trPadding: _rPadding,\n\t\tpadding: padding_d,\n\t\tflatData: _flatData,\n\t\textents: extents_d,\n\t\txDomain: xDomain_d,\n\t\tyDomain: yDomain_d,\n\t\tzDomain: zDomain_d,\n\t\trDomain: rDomain_d,\n\t\txRange: xRange_d,\n\t\tyRange: yRange_d,\n\t\tzRange: zRange_d,\n\t\trRange: rRange_d,\n\t\tconfig: _config,\n\t\txScale: xScale_d,\n\t\txGet: xGet_d,\n\t\tyScale: yScale_d,\n\t\tyGet: yGet_d,\n\t\tzScale: zScale_d,\n\t\tzGet: zGet_d,\n\t\trScale: rScale_d,\n\t\trGet: rGet_d\n\t};\n\n\t$: setContext('LayerCake', context);\n</script>\n\n{#if (ssr === true || typeof window !== 'undefined')}\n\t<div\n\t\tclass=\"layercake-container\"\n\t\tstyle=\"\n\t\t\tposition:{position};\n\t\t\t{position === 'absolute' ? 'top:0;right:0;bottom:0;left:0;' : ''}\n\t\t\t{pointerEvents === false ? 'pointer-events:none;' : ''}\n\t\t\"\n\t\tbind:clientWidth={containerWidth}\n\t\tbind:clientHeight={containerHeight}\n\t>\n\t\t<slot\n\t\t\twidth={$width_d}\n\t\t\theight={$height_d}\n\t\t\taspectRatio={$aspectRatio_d}\n\t\t\tcontainerWidth={$_containerWidth}\n\t\t\tcontainerHeight={$_containerHeight}\n\t\t></slot>\n\t</div>\n{/if}\n\n<style>\n\t.layercake-container,\n\t.layercake-container :global(*) {\n\t\tbox-sizing: border-box;\n\t}\n\t.layercake-container {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t}\n</style>\n",
    "<script>\n\timport { getContext } from 'svelte';\n\n\texport let zIndex = undefined;\n\texport let pointerEvents = undefined;\n\n\tlet zIndexStyle = '';\n\t$: zIndexStyle = typeof zIndex !== 'undefined' ? `z-index:${zIndex};` : '';\n\n\tlet pointerEventsStyle = '';\n\t$: pointerEventsStyle = pointerEvents === false ? 'pointer-events:none;' : '';\n\n\tconst { padding } = getContext('LayerCake');\n</script>\n\n<div\n\tclass=\"layercake-layout-html\"\n\tstyle=\"top: {$padding.top}px; right:{$padding.right}px; bottom:{$padding.bottom}px; left:{$padding.left}px;{zIndexStyle}{pointerEventsStyle}\"\n>\n\t<slot></slot>\n</div>\n\n<style>\n\tdiv,\n\tslot {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n</style>\n",
    "<script>\n\timport { getContext } from 'svelte';\n\n\texport let fixedAspectRatio = 1;\n\texport let viewBox = `0 0 100 ${100 / fixedAspectRatio}`;\n\texport let zIndex = undefined;\n\texport let pointerEvents = undefined;\n\n\tlet zIndexStyle = '';\n\t$: zIndexStyle = typeof zIndex !== 'undefined' ? `z-index:${zIndex};` : '';\n\n\tlet pointerEventsStyle = '';\n\t$: pointerEventsStyle = pointerEvents === false ? 'pointer-events:none;' : '';\n\n\tconst { padding } = getContext('LayerCake');\n</script>\n\n<svg\n\t{viewBox}\n\tpreserveAspectRatio=\"none\"\n\tstyle=\"top: {$padding.top}px; right:0px; bottom:0px; left:{$padding.left}px;width:calc(100% - {($padding.left + $padding.right)}px);height:calc(100% - {($padding.top + $padding.bottom)}px);{zIndexStyle}{pointerEventsStyle}\"\n>\n\t<defs>\n\t\t<slot name=\"defs\"></slot>\n\t</defs>\n\n\t<slot></slot>\n</svg>\n\n<style>\n\tsvg {\n\t\tposition: absolute;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\toverflow: visible;\n\t}\n\tsvg :global(*) {\n\t\tvector-effect: non-scaling-stroke;\n\t}\n</style>\n",
    "<script>\n\timport { getContext } from 'svelte';\n\n\texport let viewBox = undefined;\n\texport let zIndex = undefined;\n\texport let pointerEvents = undefined;\n\n\tlet zIndexStyle = '';\n\t$: zIndexStyle = typeof zIndex !== 'undefined' ? `z-index:${zIndex};` : '';\n\n\tlet pointerEventsStyle = '';\n\t$: pointerEventsStyle = pointerEvents === false ? 'pointer-events:none;' : '';\n\n\tconst { containerWidth, containerHeight, padding } = getContext('LayerCake');\n</script>\n<svg\n\tclass=\"layercake-layout-svg\"\n\t{viewBox}\n\twidth={$containerWidth}\n\theight={$containerHeight}\n\tstyle=\"{zIndexStyle}{pointerEventsStyle}\"\n>\n\t<defs>\n\t\t<slot name=\"defs\"></slot>\n\t</defs>\n\t<g transform=\"translate({$padding.left}, {$padding.top})\">\n\t\t<slot></slot>\n\t</g>\n</svg>\n\n<style>\n\tsvg {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\toverflow: visible;\n\t}\n</style>\n",
    "<script>\n  // CORE IMPORTS\n  import { setContext, onMount } from 'svelte'\n  import { getMotion } from \"./utils.js\";\n  import Scroller from './layout/Scroller.svelte'\n  import Section from './layout/Section.svelte'\n  import { themes } from \"./config.js\";\n  import ONSHeader from \"./layout/ONSHeader.svelte\";\n\timport ONSFooter from \"./layout/ONSFooter.svelte\";\n\timport Header from \"./layout/Header.svelte\";\n\timport Media from \"./layout/Media.svelte\";\n\timport Filler from \"./layout/Filler.svelte\";\n\timport Divider from \"./layout/Divider.svelte\";\n\timport Toggle from \"./ui/Toggle.svelte\";\n\timport Arrow from \"./ui/Arrow.svelte\";\n\timport Em from \"./ui/Em.svelte\";\n  import SC1 from './SC1.svelte'\n  import Map1 from './Map1.svelte'\n  import Tab_H3 from './H3.svelte'\n  import Tab_P from './P.svelte'\n  import Animated_charts from './vis_components/animated_charts/src/App.svelte'\n  import Football from './vis_components/football2/src/App.svelte'  \n  import Pyramids from './vis_components/animated_pyramids/src/App.svelte' \n  import { getData, setColors, getTopo, getBreaks, getColor } from \"./utils.js\";\n  // import archie from './scroll_section'\n  import { load } from 'archieml' //this is the parser from ArchieML to JSON\n\timport robojournalist from 'robojournalist';\n  import Vis1 from \"./vis_components/vis1/App.svelte\";\n  import { all_data } from './stores.js';\nimport { exclude_internal_props } from 'svelte/internal';\n\tlet theme = \"light\";\n  let animation = getMotion(); // Set animation preference depending on browser preference\n  import { writable } from 'svelte/store';\n  import {step} from './vis_components/animated_charts/src/step'\n  import  { disableScroll,enableScroll } from './disableScroll'\n  import { zm } from './vis_components/animated_charts/src/zm'\n  import ArrivalsDepartures from './vis_components/arrivals_departures/src/App.svelte'\n\tsetContext(\"theme\", theme);\n\tsetColors(themes, theme);\n\n//  $: console.log($all_data)\n\n  export let story\n\n  fetch('./script.aml')\n    .then((res) => res.text())\n    .then((txt) => {\n      story = load(txt).ScrollY\n    })\n//  $: console.log(story)\n\n  let components = {\n    Animated_charts: Animated_charts,\n    Football:Football,\n    Pyramids:Pyramids,\n    LA_selector_map: Vis1,\n    SC1: SC1,\n    Tab_H3: Tab_H3,\n    Tab_P: Tab_P,\n    Map1:Map1,\n    ArrivalsDepartures:ArrivalsDepartures\n  }\n  let content = ''\n\n  // Code to run Scroller actions when new caption IDs come into view\n  // State : All variables named in ArchieML to manipulate charts and maps should be listed here with starting values (same values as those in the 'foreground' section of the ArchieML)\n  let xKey = 'area' // xKey for scatter chart\n  let yKey = null // yKey for scatter chart\n  let zKey = null // zKey (color) for scatter chart\n  let rKey = null // rKey (radius) for scatter chart\n  let explore = false // Allows chart/map interactivity to be toggled on/off\n  let rubbish //note that if a variable is named in runActions but is not in the global scope, the app wont work\n  let mapKey = \"density\"; // Key for data to be displayed on map\n  let geojson;\n\t// Element bindings\n\t//let map = null; // Bound to mapbox 'map' instance once initialised\n  let map;\n  function fitBounds(bounds) {\n  //  console.log(map)\n    alert(\"fittingBounds\")\n\t\tif (map) {\n\t\t\tmap.fitBounds(bounds, {animate: animation, padding: 30});\n\t\t}}\n\t// State\n\tlet hovered; // Hovered district (chart or map)\n\tlet selected; // Selected district (chart or map)\n\tlet datasets;\n\tlet topojson;\n\tlet mapstyle;\n\tconst mapbounds = {\n\t\tuk: [\n\t\t\t[-9, 49 ],\n\t\t\t[ 2, 61 ]\n\t\t],\n        ew:[\n            [-5.6,49.5],\n            [2,56]\n        ]\n\t};\n\n\tlet mapHighlighted = [];\n  let data;\n  let metadata;\n  let bounds;\n\n\n  \n  // $: console.log(metadata)\n\t$: region = selected && metadata.district.lookup ? metadata.district.lookup[selected].parent : null; // Gets region code for 'selected'\n//\t$: chartHighlighted = metadata.district.array && region ? metadata.district.array.filter(d => d.parent == region).map(d => d.code) : []; // Array of district codes in 'region'\n  $: bounds && fitBounds(bounds)\n \n\n  // CONFIG FOR SCROLLER COMPONENTS\n  const threshold = 0.9\n  let offset\n  let id = {} // Object to hold visible section IDs of Scroller components\n  let idPrev = {} // Object to keep track of previous IDs, to compare for changes\n\n  //$: offset && (offset > 0.5) && disableScroll()// && setTimeout(enableScroll,500)\n  function runActions(codes = []) {\n    codes.forEach((code) => {\n      if (id[code] != idPrev[code]) {\n        step.set(id[code])\n   //     console.log(code)\n        idPrev[code] = id[code]\n      }\n    })\n  }\n\n\n  onMount(() => {\n    idPrev = { scatterChart: 'scatterChart01' }\n  //  console.log(id)\n    step.set(0)\n  })\n//$: console.log(id)\n\n  $: id && runActions(Object.keys(id)) // Run above code when 'id' object changes\n  $: props = {\n    SC1: { xKey, yKey, zKey, rKey, explore },\n    Map1: { bounds, mapKey, mapHighlighted, explore }\n  }\n\n// $: console.log(map)\n// $: {if(step) console.log(\"STEP\",$step,\"ID\",id)}\n// $: document.querySelector(\"#selected\") && console.log(\"bbox\",document.querySelector(\"#selected\").getBBox())\n</script>\n\n{#if story}\n<ONSHeader filled={true} center={false} />\n\n\n<Header bgcolor=\"#206095\" bgfixed={true} theme=\"dark\" center={false} short={true}>\n\t<h1>{@html  story[0].Part.headline}</h1>\n  <p style=\"margin-top: 20px\">\n\t\t09 February 2021\n\t</p>\n  <br>\n\t<p class=\"text-big\" style=\"margin-top: 5px\">\n\t\t{@html  story[0].Part.lede}\n\t</p><br>\n\n\t<p>\n\t\t<Toggle label=\"Animation {animation ? 'on' : 'off'}\" mono={true} bind:checked={animation}/>\n\t</p>\n\t<div style=\"margin-top: 90px;\">\n\t\t<Arrow color=\"white\" {animation}>Scroll to begin</Arrow>\n\t</div>\n</Header>\n\n<Filler className=\"nutgraf\" style=\"height:100vh\" theme=\"lightblue\" short={true} wide={true} center={false}>\n\t<p class=\"text-big\">\n\t\t{@html  story[0].Part.nutgraf}\n\t</p>\n  <Vis1/>\n</Filler>\n\n\n\n\n\n\n{#if $all_data}\n  {#each story as chunk, i}\n    {#if chunk.Part.type === 'Scroller'}\n      <Scroller {threshold} bind:offset={offset} bind:id={id[(chunk.Part.family)]} splitscreen={true}>\n        <div slot=\"background\">\n\n                <svelte:component\n                  this={components[chunk.Part.background]}\n                  {...props[chunk.Part.background]} \n                  />\n\n        </div>\n        <div slot=\"foreground\">\n          {#each chunk.Part.foreground as section}\n            <section {...section.section.actions}>\n              {#if section.section.content && typeof section.section.content == 'object'}\n                <div class=\"col-medium\">\n                  {#each Object.keys(section.section.content) as type}\n                    <svelte:component\n                      this={components[type]}\n                      content={section.section.content[type]} />\n                  {/each}\n                </div>\n              {:else}\n                <div class=\"col-medium\">\n                  <p>\n               {@html robojournalist(section.section.content,$all_data)}\n                  </p>\n                </div>\n              {/if}\n            </section>\n          {/each}\n        </div>\n      </Scroller>\n    {/if}\n    {#if chunk.Part.type === 'Filler'}\n    <Filler theme=\"lightblue\" short={true} wide={true} center={false}>\n      <p class=\"text-big\">\n        {@html robojournalist(chunk.Part.content,$all_data)}\n      </p>\n    </Filler>\n    {/if}\n  {/each}\n{/if}\n<Divider/>\n\n\n{/if}\n\n\n\n\n\n\n<style>\n\t/* Styles specific to elements within the demo */\n/*\t:global(svelte-scroller-foreground) {\n\t\tpointer-events: none !important;\n\t}\n\t:global(svelte-scroller-foreground section div) {\n\t\tpointer-events: none !important;\n\t}\n\t:global(svelte-scroller-background-container) {\n\t\tpointer-events: all !important;\n\t}\n\t:global(svg) {\n\t\tpointer-events: all !important;\n\t}*/\n  :global(.nutgraf){\n  height:100vh;\n  left:0\n}\n\tselect {\n\t\tmax-width: 350px;\n\t}\n\t.chart {\n\t\tmargin-top: 45px;\n\t\twidth: calc(100% - 5px);\n\t}\n\t.chart-full {\n\t\tmargin: 0 20px;\n\t}\n\t.chart-sml {\n\t\tfont-size: 0.85em;\n\t}\n\t/* The properties below make the media DIVs grey, for visual purposes in demo */\n\t.media {\n\t\tbackground-color: #f0f0f0;\n\t\tdisplay: -webkit-box;\n\t\tdisplay: -ms-flexbox;\n\t\tdisplay: flex;\n\t\t-webkit-box-orient: vertical;\n\t\t-webkit-box-direction: normal;\n\t\t-ms-flex-flow: column;\n\t\tflex-flow: column;\n\t\t-webkit-box-pack: center;\n\t\t-ms-flex-pack: center;\n\t\tjustify-content: center;\n\t\ttext-align: center;\n\t\tcolor: #aaa;\n\t}\n</style>",
    "<script>\n\timport { themes } from '../config.js';\n\timport { getContext } from 'svelte';\n\n  export let theme = getContext('theme');\n  export let hr = true;\n</script>\n\n<section style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['background']};\">\n\t<div class=\"col-medium\">\n    {#if hr}\n    <hr style=\"color: {themes[theme]['muted']}\"/>\n    {:else}\n    <hr style=\"color: {themes[theme]['muted']}; border: none;\"/>\n    {/if}\n\t</div>\n</section>\n\n<style>\n  hr {\n    width: 75px;\n    border: none;\n    border-top: 2px solid;\n    margin: 40px auto -10px auto;\n  }\n</style>\n\n",
    "<script>\n\timport { themes } from '../config.js';\n\timport { getContext } from 'svelte';\n\n\texport let theme = getContext('theme');\n\texport let center = true;\n\texport let wide = false;\n\texport let short = false;\n\texport let className = \"\"\n</script>\n\n<style>\n\tsection {\n\t\tpadding: 36px 0;\n\t}\n\t.short {\n\t\tmin-height: 70vh;\n\t}\n</style>\n\n<section class={className} style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['background']};\">\n\t<div class=\"middle\" class:center class:col-medium={!wide} class:col-wide={wide} class:height-full={!short} class:short>\n\t\t<slot></slot>\n\t</div>\n</section>",
    "<script>\n  import { themes } from '../config.js';\n\timport { getContext } from 'svelte';\n\n\texport let theme = getContext('theme');\n  export let bgimage = null;\n  export let bgcolor = null;\n  export let bgfixed = false;\n  export let center = true;\n  export let short = false;\n\n  let style = '';\n\n  if (bgimage) {\n    style += `background-image: url(${bgimage});`;\n  } else {\n    style += 'background-image: none;';\n  }\n\n  if (bgfixed) {\n    style += ' background-attachment: fixed;';\n  }\n</script>\n\n<style>\n  .short {\n    min-height: 85vh;\n  }\n  .v-padded {\n    box-sizing: border-box;\n    padding: 40px 0;\n  }\n</style>\n\n<header style=\"color: {themes[theme]['text']}; background-color: {bgcolor ? bgcolor : themes[theme]['background']}; {style}\" class:short>\n\t<div class=\"v-padded col-wide middle\" style=\"position: relative\" class:short class:height-full={!short}>\n\t\t<div class:center>\n\t\t\t<slot></slot>\n    </div>\n\t</div>\n</header>",
    "<script>\n\timport { themes } from \"../config.js\";\n\timport { onMount, getContext } from \"svelte\";\n\timport { debounce } from \"debounce\";\n\n\tconst colWidths = {\n\t\tnarrow: 200,\n\t\tmedium: 300,\n\t\twide: 500,\n\t};\n\n\texport let theme = getContext(\"theme\");\n\texport let col = \"medium\";\n\texport let grid = null;\n\texport let caption = null;\n\texport let height = 200;\n\texport let gap = 12;\n\n\tlet gridClass = grid ? ` grid-${grid}` : '';\n\n\tlet nogrid = !(\"grid-gap\" in document.body.style);\n\t\n\tlet rowHeight = !Number.isNaN(height) ? height + \"px\" : height;\n\n\tlet gridGap = !Number.isNaN(gap) ? gap + \"px\" : gap;\n\n\t// The code below this point mimics CSS Grid functionality in IE 11\n\tconst minWidth = grid && colWidths[grid] ? colWidths[grid] : null;\n\n\tlet gridWidth;\n\tlet cols;\n\n\tlet el;\n\tlet divs;\n\tlet count;\n\n\tif (nogrid) {\n\t\tonMount(() => {\n\t\t\tresize();\n\t\t});\n\t}\n\n\tconst update = debounce(resize, 200);\n\n\tfunction resize() {\n\t\tif (el && !divs) {\n\t\t\tlet arr = [];\n\t\t\tlet children = el.childNodes;\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tif (child.nodeName == \"DIV\") {\n\t\t\t\t\tarr.push(child);\n\t\t\t\t}\n\t\t\t});\n\t\t\tdivs = arr;\n\t\t}\n\t\tcount = divs.length;\n\t\tcols = !minWidth || gridWidth <= minWidth ? 1 : Math.floor(gridWidth / minWidth);\n\t\tmakeCols();\n\t}\n\n\tfunction makeCols() {\n\t\tlet r =\n\t\t\tMath.ceil(count / cols) > 1\n\t\t\t\t? `-ms-grid-rows: 1fr (${gap}px 1fr)[${\n\t\t\t\t\t\tMath.ceil(count / cols) - 1\n\t\t\t\t  }]; grid-template-rows: 1fr repeat(${\n\t\t\t\t\t\tMath.ceil(count / cols) - 1\n\t\t\t\t  }, ${gap}px 1fr);`\n\t\t\t\t: `-ms-grid-rows: 1fr; grid-template-rows: 1fr;`;\n\t\tlet c =\n\t\t\tcols > 1\n\t\t\t\t? `-ms-grid-columns: 1fr (${gap}px 1fr)[${\n\t\t\t\t\t\tcols - 1\n\t\t\t\t  }]; grid-template-columns: 1fr repeat(${cols - 1}, ${gap}px 1fr);`\n\t\t\t\t: \"\";\n\t\tel.style.cssText = r + c;\n\t\tdivs.forEach((div, i) => {\n\t\t\tlet col = (i % cols) * 2 + 1;\n\t\t\tlet row = Math.floor(i / cols) * 2 + 1;\n\t\t\tdiv.style.cssText = `-ms-grid-column: ${col}; -ms-grid-row: ${row}; grid-column: ${col}; grid-row: ${row}; min-height: ${rowHeight};`;\n\t\t});\n\t}\n\n\t$: nogrid && (minWidth || gridWidth) && update();\n</script>\n\n{#if nogrid}\n<figure style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['background']};\">\n\t<div class=\"col-{col}\">\n\t\t<div bind:this={el} bind:clientWidth={gridWidth} class=\"grid-ms\">\n\t\t\t<slot></slot>\n\t\t</div>\n\t</div>\n</figure>\n{:else}\n<figure style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['background']};\">\n\t<div class=\"col-{col}\">\n\t\t<div class=\"grid{gridClass}\" style=\"grid-gap: {gridGap}; min-height: {rowHeight}\">\n\t\t\t<slot></slot>\n\t\t</div>\n  </div>\n</figure>\n{/if}\n{#if caption}\n\t<caption style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['background']};\">\n\t\t<div class=\"col-medium\">\n\t\t\t<div class=\"caption\">{@html caption}</div>\n\t\t</div>\n\t</caption>\n{/if}\n\n<style>\n\t.grid-ms {\n\t\tdisplay: grid;\n\t\tdisplay: -ms-grid;\n\t\t-ms-grid-columns: 1fr;\n\t\tgrid-template-columns: 1fr;\n\t\tmargin-top: 40px;\n\t}\n\t.grid {\n\t\tdisplay: -ms-grid;\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(auto-fill, 100%);\n\t\tmargin: 40px 0 0 0;\n\t}\n\t.grid-narrow {\n\t\tgrid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) !important;\n\t}\n\t.grid-medium {\n\t\tgrid-template-columns: repeat(auto-fill, minmax(300px, 1fr)) !important;\n\t}\n\t.grid-wide {\n\t\tgrid-template-columns: repeat(auto-fill, minmax(500px, 1fr)) !important;\n\t}\n\t:global(.grid > div) {\n\t\tmin-height: inherit;\n\t}\n</style>\n",
    "<script>\n\timport { themes } from '../config.js';\n\timport { getContext } from 'svelte';\n\n\texport let theme = getContext('theme');\n</script>\n\n<footer style=\"color: {themes[theme]['text']}; background-color: {themes[theme]['pale']};\">\n\t<div class=\"col-wide\" data-analytics=\"footer\">\n\t\t<a href=\"https://www.ons.gov.uk/\">\n\t\t\t{#if theme == 'dark'}\n\t\t\t<img\n\t\t\t\tclass=\"logo-img\"\n\t\t\t\tsrc=\"./img/ons-logo-neg-en.svg\"\n\t\t\t\talt=\"Office for National Statistics\" />\n\t\t\t{:else}\n\t\t\t<img\n\t\t\t\tclass=\"logo-img\"\n\t\t\t\tsrc=\"./img/ons-logo-black-en.svg\"\n\t\t\t\talt=\"Office for National Statistics\" />\n\t\t\t{/if}\n\t\t</a>\n\t\t<ul>\n\t\t\t<li><a href=\"https://www.ons.gov.uk/aboutus/contactus\" class=\"link\" style=\"color: {themes[theme]['text']}\">Contact us</a></li>\n\t\t\t<li><a href=\"https://www.ons.gov.uk/help/privacynotice\" class=\"link\" style=\"color: {themes[theme]['text']}\">Cookies and privacy</a></li>\n\t\t</ul>\n\t\t<hr style=\"border-top-color: {themes[theme]['muted']}\" />\n\t\t<div class=\"license\">\n\t\t\t<svg class=\"ogl-img\" viewBox=\"0 0 59 24\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t<title>UK Open Government Licence</title>\n\t\t\t\t<path fill=\"{themes[theme]['muted']}\" d=\"M59,17.5v6.2H45.3V4l6.2-3.9v17.4H59z M33.6,13h9.8v10.7H43L40.6,21c-2.1,1.8-4.9,3-7.9,3 c-4.4,0-8.3-2.4-10.4-6.1c-2.1,3.6-5.9,6.1-10.4,6.1C5.4,23.9,0,18.6,0,12C0,5.4,5.4,0.1,11.9,0.1c4.5,0,8.4,2.5,10.4,6.1 c2.1-3.6,5.9-6.1,10.4-6.1c4.2,0,7.9,2.2,10.1,5.5l-5.2,3.3c-1-1.6-2.8-2.7-4.8-2.7C29.6,6.2,27,8.8,27,12s2.6,5.8,5.8,5.8 c1.5,0,2.8-0.5,3.8-1.4L33.6,13z M17.7,12c0-3.2-2.6-5.7-5.8-5.7S6.2,8.8,6.2,12s2.6,5.8,5.8,5.8S17.7,15.2,17.7,12z\"/>\n\t\t\t</svg>\n\t\t\tAll content is available under the\n\t\t\t<a\n\t\t\t\thref=\"https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/\"\n\t\t\t\tclass=\"link\"\n\t\t\t\ttarget=\"_blank\"\n\t\t\t\trel=\"noopener\"\n\t\t\t\tstyle=\"color: {themes[theme]['text']}\">Open Government Licence v3.0</a>, \n\t\t\texcept where otherwise stated\n\t\t</div>\n\t</div>\n</footer>\n\n<style>\n\tfooter {\n\t\tpadding-bottom: 72px;\n\t\tpadding-top: 36px;\n\t\tfont-size: 18px;\n\t}\n\tfooter a.link {\n\t\t-webkit-box-sizing: border-box;\n\t\tbox-sizing: border-box;\n\t\ttext-decoration: underline;\n\t\tdisplay: inline-block;\n\t}\n\tfooter a.link:hover {\n\t\ttext-decoration: none;\n\t}\n\tfooter a.link:active {\n\t\toutline: 3px solid transparent;\n\t\tbackground-color: #fd0;\n\t\t-webkit-box-shadow: 0 -2px #fd0, 0 4px #222;\n\t\tbox-shadow: 0 -2px #fd0, 0 4px #222;\n\t\tcolor: #222;\n\t\ttext-decoration: none;\n\t}\n\tfooter hr {\n\t\tmargin-bottom: 27px;\n\t\tmargin-top: 36px;\n\t\tborder: none;\n\t\tborder-top: 1px solid #777;\n\t}\n\tul {\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t}\n\tli {\n\t\tmargin-right: 18px;\n\t\tdisplay: inline-block;\n\t}\n\t.logo-img {\n\t\tmargin-bottom: 27px;\n\t}\n\t.ogl-img {\n\t\tmargin: 0 0.5rem 0.2rem 0;\n\t\twidth: 59px;\n\t\theight: 24px;\n\t\tvertical-align: middle;\n\t}\n\t.license {\n\t\tvertical-align: top;\n\t}\n\ta img:hover {\n\t\tcursor: pointer;\n\t}\n</style>",
    "<script>\n  import { themes } from '../config.js';\n  \n\timport { getContext } from 'svelte';\n\n\texport let theme = 'light';\n\n\texport let filled = true;\n\texport let center = true;\n</script>\n\n<nav style=\"border-bottom-color: {themes[theme]['muted']}; {filled ? 'background-color: ' +  themes[theme]['background'] + ';' : ''}\">\n  <div class=\"col-wide middle\" class:center>\n\t\t<a href=\"https://www.ons.gov.uk/\">\n\t\t\t<picture>\n\t\t\t\t{#if theme == 'dark'}\n\t\t\t\t<img src=\"./img/ons-logo-neg-en.svg\" alt=\"Office for National Statistics\">\n\t\t\t\t{:else if filled == true}\n\t\t\t\t<img src=\"./img/ons-logo-pos-en.svg\" alt=\"Office for National Statistics\">\n\t\t\t\t{:else}\n\t\t\t\t<img src=\"./img/ons-logo-black-en.svg\" alt=\"Office for National Statistics\">\n\t\t\t\t{/if}\n\t\t\t</picture>\n\t\t</a>\n  </div>\n</nav>\n\n<style>\n\tnav {\n\t\t-webkit-box-sizing: border-box;\n\t\tbox-sizing: border-box;\n\t\tposition: relative;\n\t\theight: 46px;\n\t\tmargin-bottom: -46px;\n\t\tborder-bottom: 1px solid #777;\n\t\tz-index: 1;\n\t}\n\tpicture {\n\t\tposition: relative;\n\t\ttop: -3px;\n\t\tpadding: 0 5px;\n\t}\n\timg {\n\t\twidth: 270px;\n\t}\n\ta img:hover {\n\t\tcursor: pointer;\n\t}\n</style>",
    "<script context=\"module\">\r\n  // Based on svelte-scroller by Rich Harris\r\n  // https://github.com/sveltejs/svelte-scroller\r\n  // Patched to transpile to IE 11 and allow for split-screen view option\r\n\r\n\tconst handlers = [];\r\n\tlet manager;\r\n\r\n\tif (typeof window !== 'undefined') {\r\n\t\tconst run_all = () => handlers.forEach(fn => fn());\r\n\r\n\t\twindow.addEventListener('scroll', run_all);\r\n\t\twindow.addEventListener('resize', run_all);\r\n\t}\r\n\r\n\tif (typeof IntersectionObserver !== 'undefined') {\r\n\t\tconst map = new Map();\r\n\r\n\t\tconst observer = new IntersectionObserver((entries, observer) => {\r\n\t\t\tentries.forEach(entry => {\r\n\t\t\t\tconst update = map.get(entry.target);\r\n\t\t\t\tconst index = handlers.indexOf(update);\r\n\r\n\t\t\t\tif (entry.isIntersecting) {\r\n\t\t\t\t\tif (index === -1) handlers.push(update);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tupdate();\r\n\t\t\t\t\tif (index !== -1) handlers.splice(index, 1);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}, {\r\n\t\t\trootMargin: '400px 0px' // TODO why 400?\r\n\t\t});\r\n\r\n\t\tmanager = {\r\n\t\t\tadd: ({ outer, update }) => {\r\n\t\t\t\tconst { top, bottom } = outer.getBoundingClientRect();\r\n\r\n\t\t\t\tif (top < window.innerHeight && bottom > 0) handlers.push(update);\r\n\r\n\t\t\t\tmap.set(outer, update);\r\n\t\t\t\tobserver.observe(outer);\r\n\t\t\t},\r\n\r\n\t\t\tremove: ({ outer, update }) => {\r\n\t\t\t\tconst index = handlers.indexOf(update);\r\n\t\t\t\tif (index !== -1) handlers.splice(index, 1);\r\n\r\n\t\t\t\tmap.delete(outer);\r\n\t\t\t\tobserver.unobserve(outer);\r\n\t\t\t}\r\n\t\t};\r\n\t} else {\r\n\t\tmanager = {\r\n\t\t\tadd: ({ update }) => {\r\n\t\t\t\thandlers.push(update);\r\n\t\t\t},\r\n\r\n\t\t\tremove: ({ update }) => {\r\n\t\t\t\tconst index = handlers.indexOf(update);\r\n\t\t\t\tif (index !== -1) handlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n</script>\r\n\r\n<script>\r\n\timport { onMount } from 'svelte';\r\n\r\n\t// config\r\n\texport let top = 0;\r\n\texport let bottom = 1;\r\n\texport let threshold = 0.5;\r\n\texport let query = 'section';\r\n\texport let parallax = false;\r\n\r\n\t// bindings\r\n\texport let index = 0;\r\n\texport let count = 0;\r\n\texport let offset = 0;\r\n\texport let progress = 0;\r\n\texport let visible = false;\r\n\texport let splitscreen = false; // Add class to allow for split screen option\r\n\texport let id = null;\r\n\r\n\tlet outer;\r\n  let bgContainer; // IE patch. Container binding to update inline style\r\n\tlet foreground;\r\n\tlet background;\r\n\tlet left;\r\n\tlet sections;\r\n\tlet wh = 0;\r\n\tlet fixed;\r\n\tlet offset_top;\r\n\tlet width = 1;\r\n\tlet height;\r\n\tlet inverted;\r\n\r\n\t$: top_px = Math.round(top * wh);\r\n\t$: bottom_px = Math.round(bottom * wh);\r\n\t$: threshold_px = Math.round(threshold * wh);\r\n\r\n\t$: (top, bottom, threshold, parallax, update());\r\n\r\n\tonMount(() => {\r\n\t\tsections = foreground.querySelectorAll(query);\r\n\t\tcount = sections.length;\r\n\r\n\t\tupdate();\r\n\r\n\t\tconst scroller = { outer, update };\r\n\r\n\t\tmanager.add(scroller);\r\n\t\treturn () => manager.remove(scroller);\r\n\t});\r\n\r\n\t// IE patch. BG container style (fixed/unfixed) set via function\r\n  function setFixed() {\r\n    if (bgContainer) {\r\n      let style = `position: ${fixed ? 'fixed' : 'absolute'}; top: 0; transform: translate(0, ${offset_top}px); width: ${width}px; z-index: ${inverted ? 3 : 1};`;\r\n      bgContainer.style.cssText = style;\r\n    }\r\n  }\r\n\r\n\tfunction update() {\r\n\t\tif (!foreground) return;\r\n\r\n\t\t// re-measure outer container\r\n\t\tconst bcr = outer.getBoundingClientRect();\r\n\t\tleft = bcr.left;\r\n\t\twidth = bcr.right - bcr.left;\r\n\r\n\t\t// determine fix state\r\n\t\tconst fg = foreground.getBoundingClientRect();\r\n\t\tconst bg = background.getBoundingClientRect();\r\n\r\n\t\tvisible = fg.top < wh && fg.bottom > 0;\r\n\r\n\t\tconst foreground_height = fg.bottom - fg.top;\r\n\t\tconst background_height = bg.bottom - bg.top;\r\n\r\n\t\tconst available_space = bottom_px - top_px;\r\n\t\tprogress = (top_px - fg.top) / (foreground_height - available_space);\r\n\r\n\t\tif (progress <= 0) {\r\n\t\t\toffset_top = 0;\r\n      if (fixed) {\r\n        fixed = false;\r\n        setFixed();\r\n      } // Non-IE specific patch to avoid setting style repeatedly\r\n\t\t} else if (progress >= 1) {\r\n\t\t\toffset_top = parallax\r\n\t\t\t\t? (foreground_height - background_height)\r\n\t\t\t\t: (foreground_height - available_space);\r\n      if (fixed) {\r\n        fixed = false;\r\n        setFixed();\r\n      }\r\n\t\t} else {\r\n\t\t\toffset_top = parallax ?\r\n\t\t\t\tMath.round(top_px - progress * (background_height - available_space)) :\r\n\t\t\t\ttop_px;\r\n      if (!fixed) {\r\n        fixed = true;\r\n        setFixed();\r\n      }\r\n\t\t}\r\n\r\n\t\tfor (index = 0; index < sections.length; index += 1) {\r\n\t\t\tconst section = sections[index];\r\n\t\t\tconst { top } = section.getBoundingClientRect();\r\n\r\n\t\t\tconst next = sections[index + 1];\r\n\t\t\tconst bottom = next ? next.getBoundingClientRect().top : fg.bottom;\r\n\r\n\t\t\toffset = (threshold_px - top) / (bottom - top);\r\n\t\t\tid = section.dataset.id ? section.dataset.id : null;\r\n\t\t\tif (bottom >= threshold_px) break;\r\n\t\t}\r\n\t}\r\n</script>\r\n\r\n<svelte:window bind:innerHeight={wh}/>\r\n\r\n<svelte-scroller-outer bind:this={outer} class:splitscreen>\r\n\t<svelte-scroller-background-container class='background-container' bind:this={bgContainer}>\r\n\t\t<svelte-scroller-background bind:this={background}>\r\n\t\t\t<slot name=\"background\"></slot>\r\n\t\t</svelte-scroller-background>\r\n\t</svelte-scroller-background-container>\r\n\r\n\t<svelte-scroller-foreground bind:this={foreground}>\r\n\t\t<slot name=\"foreground\"></slot>\r\n\t</svelte-scroller-foreground>\r\n</svelte-scroller-outer>\r\n\r\n<style>\r\n\tsvelte-scroller-outer {\r\n\t\tdisplay: block;\r\n\t\tposition: relative;\r\n\t\tmax-width: 100%;\r\n\t}\r\n\r\n\tsvelte-scroller-background {\r\n\t\tdisplay: block;\r\n\t\tposition: relative;\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\tsvelte-scroller-foreground {\r\n\t\tdisplay: block;\r\n\t\tposition: relative;\r\n\t\tz-index: 2;\r\n\t\tpointer-events: none;\r\n\t}\r\n\r\n\tsvelte-scroller-foreground::after {\r\n\t\tcontent: ' ';\r\n\t\tdisplay: block;\r\n\t\tclear: both;\r\n\t}\r\n\r\n\tsvelte-scroller-background-container {\r\n\t\tdisplay: block;\r\n\t\tposition: absolute;\r\n\t\twidth: 100%;\r\n\t\tmax-width: 100%;\r\n\t/*\tpointer-events: none;*/\r\n\t\t/* height: 100%; */\r\n\r\n\t\t/* in theory this helps prevent jumping */\r\n\t\twill-change: transform;\r\n\t\t/* -webkit-transform: translate3d(0, 0, 0);\r\n\t\t-moz-transform: translate3d(0, 0, 0);\r\n\t\ttransform: translate3d(0, 0, 0); */\r\n\t}\r\n</style>",
    "<script>\n  export let color = \"black\";\n  export let animation = true;\n\texport let center = true;\n\n  const colors = [\"black\", \"white\"];\n\n  color = colors.includes(color) ? color : \"black\";\n</script>\n\n{#if center}\n<slot></slot><br/>\n<img src=\"./img/scroll-down-{color}.svg\" class=\"arrow\" class:bounce={animation} alt=\"\" aria-hidden=\"true\"/>\n{:else}\n<img src=\"./img/scroll-down-{color}.svg\" class=\"arrow left\" class:bounce={animation} alt=\"\" aria-hidden=\"true\"/><slot></slot>\n{/if}\n\n<style>\n\t.arrow {\n\t\twidth: 48px;\n\t\theight: 48px;\n\t}\n\t.left {\n\t\tmargin-right: 10px;\n\t}\n\t.bounce {\n\t\t-webkit-animation-duration: 2s;\n\t\t        animation-duration: 2s;\n\t\t-webkit-animation-iteration-count: infinite;\n\t\t        animation-iteration-count: infinite;\n\t\t-webkit-animation-name: bounce;\n\t\t        animation-name: bounce;\n\t\t-webkit-animation-timing-function: ease;\n\t\t        animation-timing-function: ease;\n\t}\n\t@-webkit-keyframes bounce {\n\t\t0%   { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t\t30%  { -webkit-transform: translateY(-10px); transform: translateY(-10px); }\n\t\t50%  { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t\t100% { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t}\n\t@keyframes bounce {\n\t\t0%   { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t\t30%  { -webkit-transform: translateY(-10px); transform: translateY(-10px); }\n\t\t50%  { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t\t100% { -webkit-transform: translateY(10px); transform: translateY(10px); }\n\t}\n</style>",
    "<script>\n  import parse from 'parse-color';\n\n  export let color = 'lightgrey';\n\texport let nowrap = true;\n\n  function textColor(rgb) {\n\t\tconst brightness = ((rgb[0] * 299) + (rgb[1] * 587) + (rgb[2] * 114)) / 1000;\n\t\treturn (brightness > 125) ? 'black' : 'white';\n\t}\n\n  let text = 'black';\n\n\t$: rgb = parse(color).rgb;\n\t\n\t$: if (rgb) {\n\t\ttext = textColor(rgb);\n\t}\n\n</script>\n\n<span class=\"em\" class:nowrap style=\"background-color: {color}; color: {text};\" role=\"presentation\">\n  <slot></slot>\n</span>\n\n<style>\n\t.em {\n\t\tpadding: 1px 4px 1px 4px;\n\t\tfont-weight: bold;\n\t}\n\t.nowrap {\n\t\twhite-space: nowrap;\n\t}\n</style>",
    "<script>\n  export let id = \"switch\";\n  export let label = \"Label\";\n  export let mono = false;\n  export let checked;\n</script>\n\n<div class=\"switch\">\n  <input bind:checked {id} type=\"checkbox\" class=\"switch-input\" tabindex=\"0\" />\n  <label for={id} class=\"switch-label\" class:mono>{label}</label>\n</div>\n\n<style>\n  .switch {\n    position: relative;\n    display: inline-block;\n  }\n  .switch-input {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    margin: -1px;\n    padding: 0;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    border: 0;\n  }\n  .switch-label::before,\n  .switch-label::after {\n    content: \"\";\n    display: block;\n    position: absolute;\n    cursor: pointer;\n  }\n  .switch-label {\n    display: block;\n    cursor: pointer;\n    margin-top: -4px;\n    margin-left: 58px;\n  }\n  .switch-label::before {\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    width: 48px;\n    height: 24px;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    background-color: #aaa;\n    border-radius: 9999em;\n    -webkit-transition: background-color 0.25s ease;\n    -o-transition: background-color 0.25s ease;\n    transition: background-color 0.25s ease;\n  }\n  .switch-label::after {\n    top: 3px;\n    left: 3px;\n    width: 18px;\n    height: 18px;\n    border-radius: 50%;\n    background-color: #fff;\n    -webkit-transition: left 0.25s ease;\n    -o-transition: left 0.25s ease;\n    transition: left 0.25s ease;\n  }\n  .switch-input:checked + .switch-label::before {\n    background-color: rgb(32, 96, 149);\n  }\n  .switch-input:checked + .switch-label::after {\n    left: 27px;\n    top: 3px;\n  }\n\n  .mono::before {\n    border: 2px solid white;\n    background: none !important;\n  }\n</style>",
    "<script>\n\timport Axis from './Axis.svelte'\n  import Path from './Path.svelte'\n\timport Text from \"./Text.svelte\"\n  import { tweened } from 'svelte/motion'\n\timport { cubicInOut } from 'svelte/easing'\n  import { interpolate } from 'flubber'\n  import { geoAlbers, geoPath, geoProjection, geoMercator } from 'd3-geo'\n  import { extent } from 'd3-array'\n  import { onMount } from 'svelte'\n  import { feature } from 'topojson'\n  import { interpolateViridis } from 'd3-scale-chromatic'\n  import { select, selectAll } from 'd3-selection'\n  import { zm } from './zm'\n  import growth from './growth.js'\n  import ZoomSvg from './ZoomSvg.svelte'\n  import charts from './charts'\n  import { writable } from 'svelte/store';\n  import {step} from './step'\n  import Key from './Key.svelte'\n  import { all_data } from '../../../stores.js';\n\nconsole.log (\"ALL DATA\", $all_data)\n\tconst padding = 20\n  const width = 650 - padding*2\n  const height = 650 - padding*2\n  const mercator = geoMercator()\n    //.rotate([4.4, 0.8])\n    .center([-2, 53])\n    .scale(3500)\n    .translate([padding+width / 2, padding+height / 2])\n  const easing = cubicInOut\n\tlet axes\n\tlet loaded\n\t\n\t//$: console.log($zm)\n  let data = []\n\tlet timeline\t\n  let currentProj = mercator\n \n\tlet path = geoPath().projection(currentProj)\nvar geoJsonPoint = {\n    type: \"Point\",\n    coordinates: [0,0],\n} \n\nlet Greenwich = +path({\n    type: \"Point\",\n    coordinates: [0,0],\n} ).split(\",\")[0].slice(1);\n\t\nlet FirstMeridian = +path({\n    type: \"Point\",\n    coordinates: [10,0],\n} ).split(\",\")[0].slice(1);\n\t\n  let bar = {\n    left: 85,\n    height: 1.5,\n    scale: 0.18,\n  }\n  let newData\n  //let current = 0\n\tlet metric\n\tlet selected = writable();//=\"E09000002\"\n\tlet x=0,y=0,k=1\n//console.log(path().projection([0,0]))\n\t\n  //TIMELINE ... INITIAL SETTINGS\n  let timelineMaker = (arr) => {\n\tlet y_labels=[],x_length=800,x_labels=[],y_length=500\n\n\t\t\taxes={\t\t\t\n\t\t\t\t\t\tx_origin : tweened(Greenwich),\n\t\t\t\t\t\ty_origin : tweened(height+padding+(height/10)),\n\t\t\t\t\t\tx_length : width,\n\t\t\t\t\t\ty_length : height,\n\t\t\t\t\t\thoz_bar:[y_labels.map(e=>e.length)],\n\t\t\t\t\t\tvert_bar:[],//x_labels.map(e=>e.length),\n\t\t\t\t\t\tx_offset : tweened((Greenwich-FirstMeridian)/10),\n\t\t\t\t\t\ty_offset: tweened((Greenwich-FirstMeridian)/10),\n\t\t\t\t\t\tlabelRotation:0,\n\t\t\t\t\t\tx_zero:0,\n\t\t\t\t\t\ty_zero:0,\n\t\t\t\t\t\txTicks:true,\n\t\t\t\t\t\tyTicks:true,\n\t\t\t\t\t\txAxis:1,\n\t\t\t\t\t\tyAxis:1,\n\t\t\t\t\t\tverticalStrokes:false,\n\t\t\t\t\t\thorizontalStrokes:true\n\t\t\t}\n\t\t//console.log(\"axes\", axes)\n    let x = []\n    arr.forEach((e, i) => {\n      x.push({\n        d: tweened(arr[i].xys, { duration: 50, interpolate }),\n        centroid: arr[i].centroid,\n        fill: writable(arr[i].colour),\n        fillOpacity: tweened(1, { duration: 0, interpolate }),\n        title: writable(arr[i].properties.AREANM),\n\t\t\t\tarea_cd: writable(arr[i].properties.AREACD),\n        value: writable(arr[i].growth),\n\t\t\t\tmetric: writable(\"% change\"),\n        mouseover: mouseover,\n        mouseout: mouseout,\n\t\t\t\tpop:arr[i].pop,\n\t\t\t\ty:writable(arr[i].centroid[1]),\n\t\t\t\tselected:arr[i].properties.AREACD==$selected,\n\t\t\t\tlabel_opacity:tweened(0),\n        zoom:arr[i].zoom\n      })\n    })\n    return x\n  }\n\n\tlet zoomState={\nx:tweened(x, {duration:200}),\ny:tweened(y, {duration:200}),\nk:tweened(k, {duration:200})\n}\n  let mouseover = function (d) {\n    let title = d.target.getAttribute('title')\n    let value = d.target.getAttribute('value').toString().replace(/\\B(?<!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\")\n\t\tlet pop = d.target.getAttribute('pop')\n\t\tlet metric = d.target.getAttribute('metric')\n    select('.tooltip').style('opacity', 1)\n    select('.tooltip')\n      .html(title + '<br>' + value + metric)\n      .style('left', d.clientX + 10+ 'px')\n      .style('top', d.clientY - 28 + 'px')\n  }\n\t\n  let mouseout = function (d) { select('.tooltip').style('opacity', 0) }\n\t\n  function redrawData(datas, zm) {\n\t\t//console.log(\"PATH\",path.centroid({lat:0,long:0}))\n    data.forEach(\n      (e) =>\n        (e.growth = growth.find((el) => el.LAD17CD == e.properties.AREACD) || {\n          GROWTH: 0,\n          TOTAL11: 0,\n        }),\n    )\n    data.forEach((e) => {\n      let obj = e.growth\n      e.growth = +obj.GROWTH/100\n\t\t\te.pop = +obj.TOTAL11\n\t\t\te.abs = Math.round((+obj.GROWTH/100)*(+obj.TOTAL11)/100)\n    })\n    data.forEach((e) => (e.centroid = path.centroid(e)))\n\t\tdata.forEach((e) => (e.y = path.centroid(e)[1] *-1))\n    data.forEach((e) => (e.xys = path(e)))\n    data.forEach((e) => (e.bounds = path.bounds(e)))\n    data.forEach((e)=>e.zoom=Math.sqrt(1/(Math.max(...[e.bounds[1][0]-e.bounds[0][0],e.bounds[1][1]-e.bounds[0][1]])/width)))\n\t\tdata.forEach((e) => (e.colour= interpolateViridis(1-scaleColor(e.growth,datas,\"growth\"))))\n\t\t\n\t\t//console.log(data)\n    let extents = {\n      pop: extent(datas.map((e) => e.pop)),\n      growth: extent(datas.map((e) => e.growth)),\n\t\t\tabs:\textent(datas.map((e) => e.abs)),\n    }\n    data = data.filter((e) => e.growth !== null)//REMOVE ANY DUD DATA\n    data = data.sort((a, b) => b.growth - a.growth)//SORT BY GROWTH TO ALLOW VISIBILITY\n\n//% GROWTH BAR CHART\n\n    let bar_data = JSON.parse(JSON.stringify(growth)).filter(e=>e.REGION==$all_data.REGION_CODE).sort((a,b)=>b.GROWTH-a.GROWTH)\n    //console.log(\"BAR_DATA\",bar_data)\n    let bar_extents = {\n      growth: extent(bar_data.map((e) => e.GROWTH/100)),\n    }\n    //console.log(\"barExtents\",bar_extents)\n\t\tbar.height=(height)/bar_data.length\n\t\tbar.left=padding+(Math.abs(bar_extents.growth[0])/(bar_extents.growth[1]-bar_extents.growth[0]))*width\n\t\tbar.scale=(1/(bar_extents.growth[1]-bar_extents.growth[0]))*width\n\n\t\tlet chart=charts.find(e=>e.chart==\"bar\")\n\t\tchart.axis.x.origin=bar.left\n\t\tchart.axis.x.spacing=width/10\n\t\tchart.axis.y.origin=height+padding\n\t\tchart.axis.y.spacing=height/10\n\n    data.forEach((e, i) => {\n      e.bar = `M${0} ${0}, ${\n          0} ${0}, ${0} ${0},${0} ${0}Z`\n    })\n\n    bar_data.forEach((e, i) =>{\n      let bar_id=e.LAD17CD;\n      let data_point=data.findIndex(el=>el.properties.AREACD==bar_id)\n      if(data[data_point]){\n        //console.log(data[data_point])\n        data[data_point].bar=\n        (`M${bar.left} ${i * bar.height + padding}, ${\n          bar.left + e.GROWTH/100 * bar.scale \n        } ${i * bar.height + padding}, ${bar.left + e.GROWTH/100 *  bar.scale } ${\n          bar.height + i * bar.height\n        + padding},${bar.left} ${bar.height + i * bar.height+ padding }Z`)\n        }}\n        \n    )\ndata = data.sort((a, b) => b.growth - a.growth)\n    //console.log(\"bar_data\",data)\n\n//% NATIONAL GROWTH BAR CHART\n\nlet national_bar_data = JSON.parse(JSON.stringify(growth)).filter(e=>e.LAD17CD[0]==$selected[0]).sort((a,b)=>b.GROWTH-a.GROWTH)\n   // console.log(\"BAR_DATA\",national_bar_data)\n    let national_bar_extents = {\n      growth: extent(national_bar_data.map((e) => e.GROWTH/100)),\n    }\n    //console.log(\"barExtents\",national_bar_extents)\n\t\tbar.height=(height)/national_bar_data.length\n\t\tbar.left=padding+(Math.abs(national_bar_extents.growth[0])/(national_bar_extents.growth[1]-national_bar_extents.growth[0]))*width\n\t\tbar.scale=(1/(national_bar_extents.growth[1]-national_bar_extents.growth[0]))*width\n\n\t\tlet national_chart=charts.find(e=>e.chart==\"national_bar\")\n\t\tnational_chart.axis.x.origin=bar.left\n\t\tnational_chart.axis.x.spacing=width/10\n\t\tnational_chart.axis.y.origin=height+padding\n\t\tnational_chart.axis.y.spacing=height/10\n\n    data.forEach((e, i) => {\n      e.national_bar = `M${0} ${0}, ${\n          0} ${0}, ${0} ${0},${0} ${0}Z`\n    })\n\n    national_bar_data.forEach((e, i) =>{\n      let bar_id=e.LAD17CD;\n      let data_point=data.findIndex(el=>el.properties.AREACD==bar_id)\n      if(data[data_point]){\n        //console.log(data[data_point])\n        data[data_point].national_bar=\n        (`M${bar.left} ${i * bar.height + padding}, ${\n          bar.left + e.GROWTH/100 * bar.scale \n        } ${i * bar.height + padding}, ${bar.left + e.GROWTH/100 *  bar.scale } ${\n          bar.height + i * bar.height\n        + padding},${bar.left} ${bar.height + i * bar.height+ padding }Z`)\n        }}\n        \n    )\ndata = data.sort((a, b) => b.growth - a.growth)\n    //console.log(\"bar_data\",data)\n\n//ABSOLUTE SPIKES ON MAP\n\n\t\tchart=charts.find(e=>e.chart==\"absolute\")\n\t\tchart.axis.x.origin=Greenwich\n\t\tchart.axis.x.spacing=(Greenwich-FirstMeridian)/10\n\t\tchart.axis.y.origin=height+padding+(height/10)\n\t\tchart.axis.y.spacing=(Greenwich-FirstMeridian)/10\t\n\t\t\n\tdata=data.sort((a,b)=>b.abs-a.abs)\n\t    data.forEach((e, i) => {\n      let peak = e.pop>e.growth/10?e.pop * (e.growth/60000):1\n\n      e.absolute = peak!==1?`M${e.centroid[0]},${e.centroid[1]} ${e.centroid[0]-4},${e.centroid[1]} ${e.centroid[0]},${e.centroid[1]-(peak)} ${e.centroid[0]+4},${e.centroid[1]}z`:`M${e.centroid[0]-4}, ${e.centroid[1]} a${4},${4} 0 1,0 ${4 * 2},0 a${4},${4} 0 1,0 ${(4 * -2)},0`\n    })\t\n\n\t//ABSOLUTE BAR\n\t\t\n\t\tbar.height=(height)/data.length\n\t\tbar.left=padding+(Math.abs(extents.abs[0])/(extents.abs[1]-extents.abs[0]))*width\n\t\tbar.scale=(1/(extents.abs[1]-extents.abs[0]))*width\n\t\n\t\tchart=charts.find(e=>e.chart==\"absoluteBar\")\n\t\tchart.axis.x.origin=bar.left\n\t\tchart.axis.x.spacing=width/10\n\t\tchart.axis.y.origin=height+padding\n\t\tchart.axis.y.spacing=height/10\t\n\t\t\n\t\tdata.forEach((e, i) => {\n      let absolute = e.abs\n      e.absoluteBar = `M${bar.left} ${i * bar.height+ padding}, ${\n          bar.left + absolute * bar.scale} ${i * bar.height+ padding}, ${bar.left + absolute * bar.scale} ${\n          bar.height + i * bar.height+ padding\n        },${bar.left} ${bar.height + i * bar.height+ padding}Z`\n    })\t\t\n\t    data = data.sort((a, b) => b.growth - a.growth)//SORT BY GROWTH TO ALLOW VISIBILITY\t\t\t\n\n    \n \t//CURRENT POPULATION BAR\n\t\t\n   bar.height=(height)/data.length\n\t\tbar.left=padding+(Math.abs(extents.pop[0])/(extents.pop[1]-extents.pop[0]))*width\n\t\tbar.scale=(1/(extents.pop[1]-extents.pop[0]))*width\n\t\n\t\tchart=charts.find(e=>e.chart==\"popBar\")\n\t\tchart.axis.x.origin=bar.left+width/10\n\t\tchart.axis.x.spacing=width/10\n\t\tchart.axis.y.origin=height+padding\n\t\tchart.axis.y.spacing=height/10\t\n\n    let Data=JSON.parse(JSON.stringify(data)).sort((a,b)=>b.pop-a.pop)\n      Data.forEach((e, i) => {\n      let absolute = e.pop\n      data.find(el=>el.y-e.y==0).popBar = `M${bar.left} ${i * bar.height+ padding}, ${\n          bar.left + absolute * bar.scale} ${i * bar.height+ padding}, ${bar.left + absolute * bar.scale} ${\n          bar.height + i * bar.height+ padding\n        },${bar.left} ${bar.height + i * bar.height+ padding}Z`\n    })\t\t\n\t    data = data.sort((a, b) => b.growth - a.growth)//SORT BY GROWTH TO ALLOW VISIBILITY\t\t\t\n\n\t//POPULATION CIRCLES ON MAP\t\n\t\tchart=charts.find(e=>e.chart==\"circle\")\n\t\tchart.axis.x.origin=Greenwich\n\t\tchart.axis.x.spacing=(Greenwich-FirstMeridian)/10\n\t\tchart.axis.y.origin=height+padding+(height/10)\n\t\tchart.axis.y.spacing=(Greenwich-FirstMeridian)/10\t\n\t\t\n\n\t\t\n    data.forEach((e, i) => {\n      let radius = Math.sqrt(e.pop / (8000))\n      e.circle = `M${e.centroid[0] - radius},${\n        e.centroid[1]\n      } a${radius},${radius} 0 1,0 ${radius * 2},0 a${radius},${radius} 0 1,0 ${\n        radius * -2\n      },0Z`\n    })\n\n  \n    \t//COMPARATIVE POPULATION CIRCLES\n\t\tchart=charts.find(e=>e.chart==\"comparative_circle\")\n\t\tchart.axis.x.origin=Greenwich\n\t\tchart.axis.x.spacing=(Greenwich-FirstMeridian)/10\n\t\tchart.axis.y.origin=height+padding+(height/10)\n\t\tchart.axis.y.spacing=(Greenwich-FirstMeridian)/10\t\n\t\t\n\n\t\tlet radius_prev=0\n    Data=JSON.parse(JSON.stringify(data)).sort((a,b)=>b.pop-a.pop)\n    Data.forEach((e, i) => {\n      let radius = Math.sqrt(e.pop / (8000))\n      data.find(el=>el.y-e.y==0).comparative_circle = `M${padding},${padding + radius_prev} a${radius},${radius} 0 1,0 ${radius * 2},0 a${radius},${radius} 0 1,0 ${\n        radius * -2\n      },0Z`\n      radius_prev+=radius/2.3\n    })\n\n//SMALL POPULATION CIRCLES FOR ZOOMING\n\t\t\n    data.forEach((e, i) => {\n      let radius = Math.sqrt(e.pop / 80000)\n      e.small_circle = `M${e.centroid[0] - radius},${\n        e.centroid[1]\n      } a${radius},${radius} 0 1,0 ${radius * 2},0 a${radius},${radius} 0 1,0 ${\n        radius * -2\n      },0Z`\n    })\n//SCATTER CHART X=POPULATION SIZE, Y=GROWTH\n\t\n\t\t\n\t\tchart=charts.find(e=>e.chart==\"scatter\")\n\t\tchart.axis.x.origin=bar.left\n\t\tchart.axis.x.spacing=width/10\n\t\tchart.axis.y.origin=height-((Math.abs(extents.growth[0])/(extents.growth[1]-extents.growth[0]))*height)+(padding*2)\n\t\tchart.axis.y.spacing=height/10\t\n\t\t\n    data.forEach((e, i) => {\n      let radius = Math.sqrt(e.pop / 8000)\n      let p = (((width-(padding*2))*e.pop) / extents.pop[1]-extents.pop[0]) //e.pop/1000\n      let g = (height-(padding*2))-((height*e.growth)/(extents.growth[1]-extents.growth[0]))\n      e.scatter = `M${bar.left + p - radius}, ${g+radius} a${radius},${radius} 0 1,0 ${\n        radius * 2\n      },0 a${radius},${radius} 0 1,0 ${radius * -2},0Z`\n    })\n    timeline = timelineMaker(data)\n    setTimeout(function(){loaded=true},1000)\n    return data\n  }\n\n\n  onMount(async function () {\n\t\t\n    const response = await fetch( 'https://raw.githubusercontent.com/ONSvisual/topojson_boundaries/master/geogLA2021EW.json',\n    )\n    const json = await response.json()\n    const topoData = feature(json, json.objects.geog)\n    const land = {\n      ...topoData,\n      features: topoData.features,\n    }\n    data = land.features\n    //newData = redrawData(data, 1)\n  })\n\n  //const scaleExtent = extent(growth.map((e) => e.GROWTH))\n  const scaleColor = (val, dataSet, data) =>{\n  \tlet scaleExtent = extent(dataSet.map((e) => e[data]))\n\t\treturn  val == null\n      ? 0.5\n      : (val - scaleExtent[0]) / (scaleExtent[1] - scaleExtent[0])\n}\n\n//console.log(Object.keys(new_charts[0]))\n  function forward(current) {\n//console.log(\"SHAPES\",selectAll('.shape').sort((a,b) => ascending(a.y, b.y)))\nif (charts.length>current){\n\t\taxes.x_origin.set(charts[current].axis.x.origin)\n\t\taxes.x_offset.set(charts[current].axis.x.spacing)\n\t\taxes.y_origin.set(charts[current].axis.y.origin)\n\t\taxes.y_offset.set(charts[current].axis.y.spacing)\n\t\t\n\t\t//newData = newData.sort((a, b) => (b[charts[current].sort_by])-(a[charts[current].sort_by]))\n    let triggerZoom=0\n   // let zoomFactor=charts[current].zoom\n    let item=select(document.getElementById(\"selected\"))\n    let itemScale=item.attr(\"zoom\")\n    let zoomFactor=charts[current].zoom*itemScale\n\t\tlet focus = select(document.getElementById(\"selected\")).attr(\"centroid\").split(',').map((e,i)=>i==0?(width/2)-(zoomFactor*e):(-zoomFactor*e)+(height/2))\n    let highlighted=charts[current].highlight\n\nif(highlighted){\n\n\n}\n\nif (zoomFactor){\n  zm.set(zoomFactor)\n\ttimeline.forEach((step, i) => step.label_opacity.set(1,{duration:charts[current].duration, easing}))\n\tzoomState.x.set(focus[0],{ duration:charts[current].duration, easing})\n\tzoomState.y.set(focus[1],{ duration:charts[current].duration, easing})\n\tzoomState.k.set(zoomFactor,{ duration:charts[current].duration, easing})\n}\t\telse {\n  zm.set(1)\n\ttimeline.forEach((step, i) => step.label_opacity.set(0,{duration:10, easing}))\n\tzoomState.x.set(0,{ duration:charts[current].duration, easing})\n\tzoomState.y.set(0,{ duration:charts[current].duration, easing})\n\tzoomState.k.set(1,{ duration:charts[current].duration, easing})\n}\n    let count = 0\n\n    timeline.forEach((step, i) => {\n      count++\n      step.d.set(newData[i][charts[current].chart], {\n        duration: charts[current].duration,\n        delay: charts[current].delay * i,\n        interpolate\n      })\n\t\t\t \t//step.value= arr[i].growth/100\n\t\t\t\tstep.metric.set(charts[current].tooltip_metric)\n\t\t\t\tstep.value.set(newData[i][charts[current].value])\n\t\t\t\tstep.title.set(newData[i].properties.AREANM)\n\t\t\t\tif(charts[current].highlight){\n          step.fillOpacity.set(0.3);\n        if (charts[current].highlight==1 && Object.values($all_data.NEIGHBOURS.PC_CHANGE).map(e=>e.CODE).includes(newData[i].properties.AREACD)||newData[i].properties.AREACD==$selected)step.fillOpacity.set(1)\n        if (charts[current].highlight==2 && Object.values($all_data.REGION.HEADLINES.BIGGEST_POP_CHANGE_UP).map(e=>e.LAD17CD).includes(newData[i].properties.AREACD)||newData[i].properties.AREACD==$selected)step.fillOpacity.set(1)\n        if (charts[current].highlight==3 && ($all_data.REGION.HEADLINES.BIGGEST_POP_CHANGE_DOWN.lowest.LAD17CD==newData[i].properties.AREACD)||newData[i].properties.AREACD==$selected)step.fillOpacity.set(1)\n        if (charts[current].highlight==4 && Object.values($all_data.COUNTRY.HEADLINES.BIGGEST_POP_CHANGE_UP).map(e=>e.LAD17CD).includes(newData[i].properties.AREACD)||newData[i].properties.AREACD==$selected)step.fillOpacity.set(1)\n        if (charts[current].highlight==5 && Object.values($all_data.COUNTRY.HEADLINES.BIGGEST_POP_CHANGE_DOWN).map(e=>e.LAD17CD).includes(newData[i].properties.AREACD)||newData[i].properties.AREACD==$selected)step.fillOpacity.set(1)\n      }\n    \n    \n    else step.fillOpacity.set(1)\n      //\tconsole.log(count,newData[i].xys)\n    })\n    //current = (current + 1) % charts.length\n  }\n  }\n\t\n\tfunction back() {current = (current + charts.length - 2) % charts.length;\n\t\t\t\t\t\t\t\t\t forward()\n\t\t\t\t\t\t\t\t\t}\n$: $step && axes && loaded && forward($step)\n$: {  selected.set($all_data.CODE); newData=redrawData(data) }\n</script>\n\n<style>\n  .tooltip {\n    position: fixed;\n    text-align: center;\n    width: fit-content;\n    height: fit-content;\n    padding: 4px;\n    font: 12px sans-serif;\n    background: lightsteelblue;\n    border: 0px;\n    border-radius: 8px;\n    pointer-events: none;\n  }\n\n\n</style>\n\n\n\n<ZoomSvg id=\"charts1\" zm={$zm} {...zoomState} viewBox=\"0 0 650 650\">\n  {#if timeline}\n\t<Axis {...axes}/>\n    {#each timeline as feature, i}\n      <Path {...feature} />\n\t{/each}\n    {#each timeline as feature, i}\n   <Text {...feature}></Text>\n\t{/each}\n\t<use xlink:href=\"#selected\"/>\n\t<use xlink:href=\"#selectedText\"/>\t\n  {/if}\n\n</ZoomSvg>\n<div class=\"tooltip\" style=\"opacity:0\" />\n  <Key percent={true} key='percentage growth' uk=7.9 place={$all_data.LA.PC_CHANGE.FROM01TO11} max=30 min={-5} step={$step}></Key>",
    "<script>\n\nexport let\tx_origin,\n\t\t\t\t\t\ty_origin,\n\t\t\t\t\t\tx_offset = 0,\n\t\t\t\t\t\ty_offset= 0\n\t\n</script>\n\n\n{#each Array(30) as item,i}\n\n<!--verticals -->\n  <g transform=\"translate({$x_origin + ($x_offset * (i-15)) },0 )\">\n\t\t<line x1=0  x2=0 y1=5000 y2=-5000 stroke={i==15?\"purple\":\"lightblue\"}/>\n\t\t</g>\n\n<!--horizontals -->\n  <g transform=\"translate({$x_origin},\n{($y_origin) - ($y_offset * (i-15))} )\">\n\t\t<line x1=-500  x2=2000 y1=-0 y2=0 stroke={i==15?\"purple\":\"lightblue\"}/>\n  </g>\n{/each}\n<style>\n\tline{vector-effect: non-scaling-stroke;}\n</style>",
    "<script>\nimport { interpolateViridis } from 'd3-scale-chromatic'\nexport let percent, key, uk, place, max, min, step\nlet arr=Array.from({length: max-min+1}, (_, i) => i + min).reverse();\nlet range=max-min\nlet place_position=(max-place)/range\nlet uk_position=(max-uk)/range\n\n</script>\n\n<svg id=\"key\" height=500 viewBox=\"0 0 400 1000\">\n<text x=150 y={800} text-anchor=middle  font-size=24pt fill=grey>{key}</text>    \n{#each arr as clr,i}\n<rect width=50 height={500/arr.length} x=100 y={250 + (500/arr.length) * i} fill={interpolateViridis(i/(arr.length-1))} />\n{#if clr%10==0  || i==0 || i==arr.length-1}<text x=90 y={260 + ((500/arr.length) * i)} fill=grey text-anchor=end>{clr}{percent?\"%\":\"\"}</text>{/if}\n{/each}\n<line x1={100} x2={180} y1={250 + (500 * place_position)} y2={250+ (place_position*(500))} stroke=darkblue stroke-width=8 stroke-linecap=\"round\" ></line>\n<text x=160 y={240 + (place_position*(500))} fill=darkblue font-size=24pt>here</text>\n{#if step==1}<line x1={100} x2={180} y1={250 + (uk_position*(500))} y2={250 + (uk_position*(500))} stroke=darkred stroke-width=8 stroke-linecap=\"round\" ></line>\n<text x=160 y={240 + (uk_position*(500))} fill=darkred font-size=24pt>average</text>{/if}\n<text x=160 y={260} fill=grey font-size=24pt>Tower</text>\n<text x=160 y={290} fill=grey font-size=24pt>Hamlets</text>\n<text x=160 y={725} fill=grey font-size=24pt>Barrow-</text>\n<text x=160 y={755} fill=grey font-size=24pt>in-Furness</text>\n</svg>\n\n<style>\n    #key{\n        position:fixed;\n        right: 95vh;\n    }\n</style>",
    "<script>\n  import { onMount } from 'svelte'\n\timport {zm} from \"./zm\"\n  export let viewBox = '0 0 300 150', height=650, width=650\n\texport let svg,x,y,k\n\n</script>\n\n<svg id=\"canvas\" viewBox={viewBox} height={height} width={width} bind:this={svg} zm={$zm}>\n  <g transform=\"translate({$x}, {$y}) scale({$k})\" id=\"zoomable\">\n    <slot></slot>\n  </g>\n</svg>\n<style>\n  #canvas {\nposition: absolute;\nright:0;\nheight:100vh;\nwidth:100vh;\n  }\n</style>"
  ],
  "names": [],
  "mappings": "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"
}